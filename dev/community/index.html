<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Community Structures · Graphs.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Graphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Graphs.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><a class="tocitem" href="../graphtypes/">Choosing A Graph Type</a></li><li><a class="tocitem" href="../types/">Graphs Types</a></li><li><a class="tocitem" href="../basicproperties/">Accessing Properties</a></li><li><a class="tocitem" href="../generators/">Making and Modifying Graphs</a></li><li><a class="tocitem" href="../persistence/">Reading / Writing Graphs</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../core/">Core Functions</a></li><li><a class="tocitem" href="../plotting/">Plotting Graphs</a></li><li><a class="tocitem" href="../pathing/">Path and Traversal</a></li><li><a class="tocitem" href="../coloring/">Coloring</a></li><li><a class="tocitem" href="../distance/">Distance</a></li><li><a class="tocitem" href="../centrality/">Centrality Measures</a></li><li><a class="tocitem" href="../linalg/">Linear Algebra</a></li><li><a class="tocitem" href="../matching/">Matching</a></li><li class="is-active"><a class="tocitem" href>Community Structures</a><ul class="internal"><li><a class="tocitem" href="#Full-Docs"><span>Full Docs</span></a></li></ul></li><li><a class="tocitem" href="../degeneracy/">Degeneracy</a></li><li><a class="tocitem" href="../integration/">Integration with other packages</a></li><li><a class="tocitem" href="../experimental/">Experimental Functionality</a></li><li><a class="tocitem" href="../parallel/">Parallel Algorithms</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../developing/">Developer Notes</a></li><li><a class="tocitem" href="../license/">License Information</a></li><li><a class="tocitem" href="../citing/">Citing Graphs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Community Structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Community Structures</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphs/Graphs.jl/blob/master/docs/src/community.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Community-Structures"><a class="docs-heading-anchor" href="#Community-Structures">Community Structures</a><a id="Community-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Community-Structures" title="Permalink"></a></h1><p><em>Graphs.jl</em> contains many algorithm to detect and analyze community structures in graphs. These include:</p><ul><li><a href="#Graphs.AbstractEdge"><code>Graphs.AbstractEdge</code></a></li><li><a href="#Graphs.AbstractEdgeIter"><code>Graphs.AbstractEdgeIter</code></a></li><li><a href="#Graphs.AbstractGraph"><code>Graphs.AbstractGraph</code></a></li><li><a href="#Graphs.AbstractPathState"><code>Graphs.AbstractPathState</code></a></li><li><a href="#Graphs.BellmanFordState"><code>Graphs.BellmanFordState</code></a></li><li><a href="#Graphs.Biconnections"><code>Graphs.Biconnections</code></a></li><li><a href="#Graphs.DEsopoPapeState"><code>Graphs.DEsopoPapeState</code></a></li><li><a href="#Graphs.DefaultDistance"><code>Graphs.DefaultDistance</code></a></li><li><a href="#Graphs.DiGraph"><code>Graphs.DiGraph</code></a></li><li><a href="#Graphs.DijkstraState"><code>Graphs.DijkstraState</code></a></li><li><a href="#Graphs.Edge"><code>Graphs.Edge</code></a></li><li><a href="#Graphs.FloydWarshallState"><code>Graphs.FloydWarshallState</code></a></li><li><a href="#Graphs.Graph"><code>Graphs.Graph</code></a></li><li><a href="#Graphs.JohnsonState"><code>Graphs.JohnsonState</code></a></li><li><a href="#Graphs.JohnsonVisitor"><code>Graphs.JohnsonVisitor</code></a></li><li><a href="#Graphs.NeighComm"><code>Graphs.NeighComm</code></a></li><li><a href="#Graphs.NotImplementedError"><code>Graphs.NotImplementedError</code></a></li><li><a href="#Graphs.YenState"><code>Graphs.YenState</code></a></li><li><a href="#Base.eltype-Tuple{AbstractGraph}"><code>Base.eltype</code></a></li><li><a href="#Base.getindex-Tuple{AbstractGraph, Any}"><code>Base.getindex</code></a></li><li><a href="#Base.intersect-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Base.intersect</code></a></li><li><a href="#Base.join-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Base.join</code></a></li><li><a href="#Base.reverse"><code>Base.reverse</code></a></li><li><a href="#Base.reverse-Tuple{AbstractEdge}"><code>Base.reverse</code></a></li><li><a href="#Base.reverse!"><code>Base.reverse!</code></a></li><li><a href="#Base.size-Tuple{SimpleGraph, Int64}"><code>Base.size</code></a></li><li><a href="#Base.sum-Tuple{AbstractGraph, Int64}"><code>Base.sum</code></a></li><li><a href="#Base.sum-Tuple{AbstractGraph}"><code>Base.sum</code></a></li><li><a href="#Base.union-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph"><code>Base.union</code></a></li><li><a href="#Base.zero-Tuple{Type{&lt;:AbstractGraph}}"><code>Base.zero</code></a></li><li><a href="#Graphs.BoundedMinkowskiCost-Tuple{AbstractVector, AbstractVector}"><code>Graphs.BoundedMinkowskiCost</code></a></li><li><a href="#Graphs.MinkowskiCost-Tuple{AbstractVector, AbstractVector}"><code>Graphs.MinkowskiCost</code></a></li><li><a href="#Graphs.a_star-Union{Tuple{U}, Tuple{T}, Tuple{AbstractGraph{U}, Integer, Integer}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}, Function}} where {T, U}"><code>Graphs.a_star</code></a></li><li><a href="#Graphs.add_vertices!-Tuple{AbstractGraph, Integer}"><code>Graphs.add_vertices!</code></a></li><li><a href="#Graphs.all_neighbors"><code>Graphs.all_neighbors</code></a></li><li><a href="#Graphs.articulation"><code>Graphs.articulation</code></a></li><li><a href="#Graphs.assortativity-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.assortativity</code></a></li><li><a href="#Graphs.attracting_components"><code>Graphs.attracting_components</code></a></li><li><a href="#Graphs.bellman_ford_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector{&lt;:Integer}}, Tuple{AbstractGraph{U}, AbstractVector{&lt;:Integer}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.bellman_ford_shortest_paths</code></a></li><li><a href="#Graphs.bfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_parents</code></a></li><li><a href="#Graphs.bfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_tree</code></a></li><li><a href="#Graphs.biconnected_components"><code>Graphs.biconnected_components</code></a></li><li><a href="#Graphs.bipartite_map-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.bipartite_map</code></a></li><li><a href="#Graphs.boruvka_mst"><code>Graphs.boruvka_mst</code></a></li><li><a href="#Graphs.bridges"><code>Graphs.bridges</code></a></li><li><a href="#Graphs.cartesian_product-Union{Tuple{G}, Tuple{G, G}} where G&lt;:AbstractGraph"><code>Graphs.cartesian_product</code></a></li><li><a href="#Graphs.center-Tuple{Vector}"><code>Graphs.center</code></a></li><li><a href="#Graphs.circuit"><code>Graphs.circuit</code></a></li><li><a href="#Graphs.circuit_iter"><code>Graphs.circuit_iter</code></a></li><li><a href="#Graphs.circuit_recursive!"><code>Graphs.circuit_recursive!</code></a></li><li><a href="#Graphs.clique_percolation"><code>Graphs.clique_percolation</code></a></li><li><a href="#Graphs.common_neighbors-Tuple{AbstractGraph, Integer, Integer}"><code>Graphs.common_neighbors</code></a></li><li><a href="#Graphs.complement-Tuple{SimpleGraph}"><code>Graphs.complement</code></a></li><li><a href="#Graphs.components-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.components</code></a></li><li><a href="#Graphs.components_dict-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.components_dict</code></a></li><li><a href="#Graphs.compute_shifts-Tuple{Integer, AbstractArray}"><code>Graphs.compute_shifts</code></a></li><li><a href="#Graphs.condensation"><code>Graphs.condensation</code></a></li><li><a href="#Graphs.connected_components-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.connected_components</code></a></li><li><a href="#Graphs.connected_components!-Union{Tuple{T}, Tuple{AbstractVector, AbstractGraph{T}}} where T"><code>Graphs.connected_components!</code></a></li><li><a href="#Graphs.core_number-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.core_number</code></a></li><li><a href="#Graphs.core_periphery_deg"><code>Graphs.core_periphery_deg</code></a></li><li><a href="#Graphs.crosspath"><code>Graphs.crosspath</code></a></li><li><a href="#Graphs.cycle_basis"><code>Graphs.cycle_basis</code></a></li><li><a href="#Graphs.deepcopy_adjlist-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T"><code>Graphs.deepcopy_adjlist</code></a></li><li><a href="#Graphs.degree"><code>Graphs.degree</code></a></li><li><a href="#Graphs.degree_histogram-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.degree_histogram</code></a></li><li><a href="#Graphs.density"><code>Graphs.density</code></a></li><li><a href="#Graphs.desopo_pape_shortest_paths-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.desopo_pape_shortest_paths</code></a></li><li><a href="#Graphs.dfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_parents</code></a></li><li><a href="#Graphs.dfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_tree</code></a></li><li><a href="#Graphs.diameter-Tuple{Vector}"><code>Graphs.diameter</code></a></li><li><a href="#Graphs.difference-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Graphs.difference</code></a></li><li><a href="#Graphs.diffusion-Union{Tuple{T}, Tuple{AbstractGraph{T}, Real, Integer}} where T"><code>Graphs.diffusion</code></a></li><li><a href="#Graphs.diffusion_rate-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.diffusion_rate</code></a></li><li><a href="#Graphs.dijkstra_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, Vector{U}}, Tuple{AbstractGraph, Vector{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.dijkstra_shortest_paths</code></a></li><li><a href="#Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeDominatingSet}} where T&lt;:Integer"><code>Graphs.dominating_set</code></a></li><li><a href="#Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MinimalDominatingSet}} where T&lt;:Integer"><code>Graphs.dominating_set</code></a></li><li><a href="#Graphs.dst-Tuple{AbstractEdge}"><code>Graphs.dst</code></a></li><li><a href="#Graphs.eccentricity-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.eccentricity</code></a></li><li><a href="#Graphs.edges-Tuple{Any}"><code>Graphs.edges</code></a></li><li><a href="#Graphs.edgetype-Tuple{AbstractGraph}"><code>Graphs.edgetype</code></a></li><li><a href="#Graphs.edit_distance-Tuple{AbstractGraph, AbstractGraph}"><code>Graphs.edit_distance</code></a></li><li><a href="#Graphs.egonet-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Integer}, Tuple{AbstractGraph{T}, Integer, Integer, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}"><code>Graphs.egonet</code></a></li><li><a href="#Graphs.enumerate_paths-Tuple{Graphs.AbstractPathState, AbstractVector{&lt;:Integer}}"><code>Graphs.enumerate_paths</code></a></li><li><a href="#Graphs.filter_non_term_leaves!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.filter_non_term_leaves!</code></a></li><li><a href="#Graphs.findall!-Union{Tuple{T}, Tuple{Union{BitVector, Vector{Bool}}, Vector{T}}} where T&lt;:Integer"><code>Graphs.findall!</code></a></li><li><a href="#Graphs.floyd_warshall_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.floyd_warshall_shortest_paths</code></a></li><li><a href="#Graphs.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.gdistances</code></a></li><li><a href="#Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T"><code>Graphs.gdistances!</code></a></li><li><a href="#Graphs.global_clustering_coefficient-Tuple{AbstractGraph}"><code>Graphs.global_clustering_coefficient</code></a></li><li><a href="#Graphs.greedy_contiguous_partition-Union{Tuple{U}, Tuple{Vector{&lt;:Integer}, Integer}, Tuple{Vector{&lt;:Integer}, Integer, U}} where U&lt;:Integer"><code>Graphs.greedy_contiguous_partition</code></a></li><li><a href="#Graphs.has_edge-Tuple{Any, Any, Any}"><code>Graphs.has_edge</code></a></li><li><a href="#Graphs.has_negative_edge_cycle_spfa-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.has_negative_edge_cycle_spfa</code></a></li><li><a href="#Graphs.has_path-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Integer}} where T"><code>Graphs.has_path</code></a></li><li><a href="#Graphs.has_self_loops-Tuple{AbstractGraph}"><code>Graphs.has_self_loops</code></a></li><li><a href="#Graphs.has_vertex-Tuple{Any, Any}"><code>Graphs.has_vertex</code></a></li><li><a href="#Graphs.indegree-Tuple{AbstractGraph, Integer}"><code>Graphs.indegree</code></a></li><li><a href="#Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MaximalIndependentSet}} where T&lt;:Integer"><code>Graphs.independent_set</code></a></li><li><a href="#Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeIndependentSet}} where T&lt;:Integer"><code>Graphs.independent_set</code></a></li><li><a href="#Graphs.induced_subgraph-Union{Tuple{T}, Tuple{U}, Tuple{T, AbstractVector{U}}} where {U&lt;:Integer, T&lt;:AbstractGraph}"><code>Graphs.induced_subgraph</code></a></li><li><a href="#Graphs.inneighbors-Tuple{Any, Any}"><code>Graphs.inneighbors</code></a></li><li><a href="#Graphs.insorted-Tuple{Any, Any}"><code>Graphs.insorted</code></a></li><li><a href="#Graphs.is_bipartite-Tuple{AbstractGraph}"><code>Graphs.is_bipartite</code></a></li><li><a href="#Graphs.is_connected-Tuple{AbstractGraph}"><code>Graphs.is_connected</code></a></li><li><a href="#Graphs.is_cyclic"><code>Graphs.is_cyclic</code></a></li><li><a href="#Graphs.is_directed-Tuple{G} where G"><code>Graphs.is_directed</code></a></li><li><a href="#Graphs.is_ordered-Tuple{AbstractEdge}"><code>Graphs.is_ordered</code></a></li><li><a href="#Graphs.is_strongly_connected"><code>Graphs.is_strongly_connected</code></a></li><li><a href="#Graphs.is_weakly_connected-Tuple{Any}"><code>Graphs.is_weakly_connected</code></a></li><li><a href="#Graphs.isbounded-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.isbounded</code></a></li><li><a href="#Graphs.isbounded-Tuple{Integer}"><code>Graphs.isbounded</code></a></li><li><a href="#Graphs.isgraphical-Tuple{Vector{&lt;:Integer}}"><code>Graphs.isgraphical</code></a></li><li><a href="#Graphs.itercycles"><code>Graphs.itercycles</code></a></li><li><a href="#Graphs.johnson_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.johnson_shortest_paths</code></a></li><li><a href="#Graphs.k_core"><code>Graphs.k_core</code></a></li><li><a href="#Graphs.k_corona-Tuple{AbstractGraph, Any}"><code>Graphs.k_corona</code></a></li><li><a href="#Graphs.k_crust"><code>Graphs.k_crust</code></a></li><li><a href="#Graphs.k_shell"><code>Graphs.k_shell</code></a></li><li><a href="#Graphs.karger_cut_cost-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.karger_cut_cost</code></a></li><li><a href="#Graphs.karger_cut_edges-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.karger_cut_edges</code></a></li><li><a href="#Graphs.karger_min_cut-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.karger_min_cut</code></a></li><li><a href="#Graphs.karp_minimum_cycle_mean"><code>Graphs.karp_minimum_cycle_mean</code></a></li><li><a href="#Graphs.kruskal_mst"><code>Graphs.kruskal_mst</code></a></li><li><a href="#Graphs.label_propagation-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.label_propagation</code></a></li><li><a href="#Graphs.loadgraph-Tuple{AbstractString, AbstractString, Graphs.AbstractGraphFormat}"><code>Graphs.loadgraph</code></a></li><li><a href="#Graphs.loadgraphs-Tuple{AbstractString, Graphs.AbstractGraphFormat}"><code>Graphs.loadgraphs</code></a></li><li><a href="#Graphs.loadlg_mult-Tuple{IO}"><code>Graphs.loadlg_mult</code></a></li><li><a href="#Graphs.local_clustering-Tuple{AbstractGraph, Integer}"><code>Graphs.local_clustering</code></a></li><li><a href="#Graphs.local_clustering_coefficient-Tuple{AbstractGraph, Integer}"><code>Graphs.local_clustering_coefficient</code></a></li><li><a href="#Graphs.maximal_cliques"><code>Graphs.maximal_cliques</code></a></li><li><a href="#Graphs.maximum_adjacency_visit-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO, U}} where {U, T&lt;:Real}"><code>Graphs.maximum_adjacency_visit</code></a></li><li><a href="#Graphs.maxsimplecycles"><code>Graphs.maxsimplecycles</code></a></li><li><a href="#Graphs.maxsimplecycles-Tuple{Integer}"><code>Graphs.maxsimplecycles</code></a></li><li><a href="#Graphs.merge_vertices-Tuple{Graphs.SimpleGraphs.AbstractSimpleGraph, Any}"><code>Graphs.merge_vertices</code></a></li><li><a href="#Graphs.merge_vertices!-Union{Tuple{T}, Tuple{SimpleGraph{T}, Vector{U} where U&lt;:Integer}} where T"><code>Graphs.merge_vertices!</code></a></li><li><a href="#Graphs.mincut-Union{Tuple{AbstractGraph}, Tuple{T}, Tuple{AbstractGraph, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.mincut</code></a></li><li><a href="#Graphs.modularity-Tuple{AbstractGraph, AbstractVector{&lt;:Integer}}"><code>Graphs.modularity</code></a></li><li><a href="#Graphs.ncycles_n_i-Tuple{Integer, Integer}"><code>Graphs.ncycles_n_i</code></a></li><li><a href="#Graphs.ne-Tuple{AbstractGraph}"><code>Graphs.ne</code></a></li><li><a href="#Graphs.neighborhood-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}"><code>Graphs.neighborhood</code></a></li><li><a href="#Graphs.neighborhood_dists-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}"><code>Graphs.neighborhood_dists</code></a></li><li><a href="#Graphs.neighbors-Tuple{AbstractGraph, Integer}"><code>Graphs.neighbors</code></a></li><li><a href="#Graphs.noallocextreme-NTuple{4, Any}"><code>Graphs.noallocextreme</code></a></li><li><a href="#Graphs.non_backtracking_randomwalk"><code>Graphs.non_backtracking_randomwalk</code></a></li><li><a href="#Graphs.normalized_cut-Union{Tuple{T}, Tuple{AbstractGraph, Real}, Tuple{AbstractGraph, Real, AbstractMatrix{T}}, Tuple{AbstractGraph, Real, AbstractMatrix{T}, Int64}} where T&lt;:Real"><code>Graphs.normalized_cut</code></a></li><li><a href="#Graphs.num_self_loops-Tuple{AbstractGraph}"><code>Graphs.num_self_loops</code></a></li><li><a href="#Graphs.nv-Tuple{AbstractGraph}"><code>Graphs.nv</code></a></li><li><a href="#Graphs.optimal_contiguous_partition-Union{Tuple{U}, Tuple{Vector{&lt;:Integer}, Integer}, Tuple{Vector{&lt;:Integer}, Integer, U}} where U&lt;:Integer"><code>Graphs.optimal_contiguous_partition</code></a></li><li><a href="#Graphs.outdegree-Tuple{AbstractGraph, Integer}"><code>Graphs.outdegree</code></a></li><li><a href="#Graphs.outneighbors-Tuple{Any, Any}"><code>Graphs.outneighbors</code></a></li><li><a href="#Graphs.period"><code>Graphs.period</code></a></li><li><a href="#Graphs.periphery-Tuple{Vector}"><code>Graphs.periphery</code></a></li><li><a href="#Graphs.prim_mst"><code>Graphs.prim_mst</code></a></li><li><a href="#Graphs.radius-Tuple{Vector}"><code>Graphs.radius</code></a></li><li><a href="#Graphs.randomwalk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.randomwalk</code></a></li><li><a href="#Graphs.range_shuffle!-Tuple{UnitRange, AbstractVector}"><code>Graphs.range_shuffle!</code></a></li><li><a href="#Graphs.resetB!-Tuple{Any}"><code>Graphs.resetB!</code></a></li><li><a href="#Graphs.resetblocked!-Tuple{Any}"><code>Graphs.resetblocked!</code></a></li><li><a href="#Graphs.rich_club-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}} where T"><code>Graphs.rich_club</code></a></li><li><a href="#Graphs.sample-Tuple{AbstractVector, Integer}"><code>Graphs.sample</code></a></li><li><a href="#Graphs.sample!-Tuple{Random.AbstractRNG, AbstractVector, Integer}"><code>Graphs.sample!</code></a></li><li><a href="#Graphs.savegraph-Tuple{AbstractString, AbstractGraph, AbstractString, Graphs.AbstractGraphFormat}"><code>Graphs.savegraph</code></a></li><li><a href="#Graphs.savegraph-Union{Tuple{T}, Tuple{U}, Tuple{AbstractString, Dict{T, U}, Graphs.AbstractGraphFormat}} where {U&lt;:AbstractGraph, T&lt;:AbstractString}"><code>Graphs.savegraph</code></a></li><li><a href="#Graphs.savelg-Union{Tuple{T}, Tuple{IO, AbstractGraph{T}, String}} where T"><code>Graphs.savelg</code></a></li><li><a href="#Graphs.savelg_mult-Tuple{IO, Dict}"><code>Graphs.savelg_mult</code></a></li><li><a href="#Graphs.self_avoiding_walk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.self_avoiding_walk</code></a></li><li><a href="#Graphs.simplecycles"><code>Graphs.simplecycles</code></a></li><li><a href="#Graphs.simplecycles_hawick_james"><code>Graphs.simplecycles_hawick_james</code></a></li><li><a href="#Graphs.simplecycles_iter"><code>Graphs.simplecycles_iter</code></a></li><li><a href="#Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T"><code>Graphs.simplecycles_limited_length</code></a></li><li><a href="#Graphs.simplecyclescount"><code>Graphs.simplecyclescount</code></a></li><li><a href="#Graphs.simplecycleslength"><code>Graphs.simplecycleslength</code></a></li><li><a href="#Graphs.spfa_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, Integer}, Tuple{AbstractGraph{U}, Integer, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.spfa_shortest_paths</code></a></li><li><a href="#Graphs.squash-Tuple{AbstractGraph}"><code>Graphs.squash</code></a></li><li><a href="#Graphs.src-Tuple{AbstractEdge}"><code>Graphs.src</code></a></li><li><a href="#Graphs.steiner_tree"><code>Graphs.steiner_tree</code></a></li><li><a href="#Graphs.strongly_connected_components"><code>Graphs.strongly_connected_components</code></a></li><li><a href="#Graphs.strongly_connected_components_kosaraju"><code>Graphs.strongly_connected_components_kosaraju</code></a></li><li><a href="#Graphs.symmetric_difference-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Graphs.symmetric_difference</code></a></li><li><a href="#Graphs.tensor_product-Union{Tuple{G}, Tuple{G, G}} where G&lt;:AbstractGraph"><code>Graphs.tensor_product</code></a></li><li><a href="#Graphs.topological_sort_by_dfs"><code>Graphs.topological_sort_by_dfs</code></a></li><li><a href="#Graphs.transitiveclosure"><code>Graphs.transitiveclosure</code></a></li><li><a href="#Graphs.transitiveclosure!"><code>Graphs.transitiveclosure!</code></a></li><li><a href="#Graphs.transitivereducion"><code>Graphs.transitivereducion</code></a></li><li><a href="#Graphs.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.tree</code></a></li><li><a href="#Graphs.triangles-Tuple{AbstractGraph, Integer}"><code>Graphs.triangles</code></a></li><li><a href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, AbstractVector, Array{Vector{T}, 1}}} where T"><code>Graphs.unblock!</code></a></li><li><a href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, BitVector, Array{Set{T}, 1}}} where T&lt;:Integer"><code>Graphs.unblock!</code></a></li><li><a href="#Graphs.unweighted_contiguous_partition-Tuple{Integer, Integer}"><code>Graphs.unweighted_contiguous_partition</code></a></li><li><a href="#Graphs.update_dominated!-Union{Tuple{T}, Tuple{AbstractGraph{T}, DataStructures.PriorityQueue, Integer, BitVector, BitVector}} where T&lt;:Integer"><code>Graphs.update_dominated!</code></a></li><li><a href="#Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, RandomVertexCover}} where T&lt;:Integer"><code>Graphs.vertex_cover</code></a></li><li><a href="#Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeVertexCover}} where T&lt;:Integer"><code>Graphs.vertex_cover</code></a></li><li><a href="#Graphs.vertices-Tuple{AbstractGraph}"><code>Graphs.vertices</code></a></li><li><a href="#Graphs.visit!-Union{Tuple{E}, Tuple{AbstractGraph, Graphs.Biconnections{E}, Integer, Integer}} where E"><code>Graphs.visit!</code></a></li><li><a href="#Graphs.vote!-Tuple{AbstractGraph, Vector, Graphs.NeighComm, Integer}"><code>Graphs.vote!</code></a></li><li><a href="#Graphs.weakly_connected_components-Tuple{Any}"><code>Graphs.weakly_connected_components</code></a></li><li><a href="#Graphs.weights-Tuple{AbstractGraph}"><code>Graphs.weights</code></a></li><li><a href="#Graphs.yen_k_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, U, U}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}, Int64}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.yen_k_shortest_paths</code></a></li><li><a href="#Graphs.Δ-Tuple{Any}"><code>Graphs.Δ</code></a></li><li><a href="#Graphs.Δin-Tuple{Any}"><code>Graphs.Δin</code></a></li><li><a href="#Graphs.Δout-Tuple{Any}"><code>Graphs.Δout</code></a></li><li><a href="#Graphs.δ-Tuple{Any}"><code>Graphs.δ</code></a></li><li><a href="#Graphs.δin-Tuple{Any}"><code>Graphs.δin</code></a></li><li><a href="#Graphs.δout-Tuple{Any}"><code>Graphs.δout</code></a></li><li><a href="#SparseArrays.blockdiag-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>SparseArrays.blockdiag</code></a></li><li><a href="#SparseArrays.sparse-Tuple{AbstractGraph}"><code>SparseArrays.sparse</code></a></li></ul><h2 id="Full-Docs"><a class="docs-heading-anchor" href="#Full-Docs">Full Docs</a><a id="Full-Docs-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Graphs.Graphs" href="#Graphs.Graphs"><code>Graphs.Graphs</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Graphs</code></pre><p>An optimized graphs package.</p><p>Simple graphs (not multi- or hypergraphs) are represented in a memory- and time-efficient manner with adjacency lists and edge sets. Both directed and undirected graphs are supported via separate types, and conversion is available from directed to undirected.</p><p>The project goal is to mirror the functionality of robust network and graph analysis libraries such as NetworkX while being simpler to use and more efficient than existing Julian graph libraries such as Graphs.jl. It is an explicit design decision that any data not required for graph manipulation (attributes and other information, for example) is expected to be stored outside of the graph structure itself. Such data lends itself to storage in more traditional and better-optimized mechanisms.</p><p><a href="http://codecov.io/github/JuliaGraphs/Graphs.jl">Full documentation</a> is available, and tutorials are available at the <a href="https://github.com/JuliaGraphs/JuliaGraphsTutorials">JuliaGraphsTutorials repository</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/Graphs.jl#L165-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.AbstractEdge" href="#Graphs.AbstractEdge"><code>Graphs.AbstractEdge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEdge</code></pre><p>An abstract type representing a single edge between two vertices of a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.AbstractEdgeIter" href="#Graphs.AbstractEdgeIter"><code>Graphs.AbstractEdgeIter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEdgeIter</code></pre><p>An abstract type representing an edge iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.AbstractGraph" href="#Graphs.AbstractGraph"><code>Graphs.AbstractGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractGraph</code></pre><p>An abstract type representing a graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.AbstractPathState" href="#Graphs.AbstractPathState"><code>Graphs.AbstractPathState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPathState</code></pre><p>An abstract type that provides information from shortest paths calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.BellmanFordState" href="#Graphs.BellmanFordState"><code>Graphs.BellmanFordState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BellmanFordState{T, U}</code></pre><p>An <code>AbstractPathState</code> designed for Bellman-Ford shortest-paths calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/bellman-ford.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Biconnections" href="#Graphs.Biconnections"><code>Graphs.Biconnections</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Biconnections</code></pre><p>A state type for depth-first search that finds the biconnected components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/biconnectivity/biconnect.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.DEsopoPapeState" href="#Graphs.DEsopoPapeState"><code>Graphs.DEsopoPapeState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DEposoPapeState{T, U}</code></pre><p>An <a href="#Graphs.AbstractPathState"><code>AbstractPathState</code></a> designed for D`Esopo-Pape shortest-path calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/desopo-pape.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.DefaultDistance" href="#Graphs.DefaultDistance"><code>Graphs.DefaultDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultDistance</code></pre><p>An array-like structure that provides distance values of <code>1</code> for any <code>src, dst</code> combination.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/distance.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.DiGraph" href="#Graphs.DiGraph"><code>Graphs.DiGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiGraph</code></pre><p>A datastruture representing a directed graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/Graphs.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.DijkstraState" href="#Graphs.DijkstraState"><code>Graphs.DijkstraState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DijkstraState{T, U}</code></pre><p>An <a href="#Graphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Dijkstra shortest-paths calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/dijkstra.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Edge" href="#Graphs.Edge"><code>Graphs.Edge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Edge</code></pre><p>A datastruture representing an edge between two vertices in a <code>Graph</code> or <code>DiGraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/Graphs.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.FloydWarshallState" href="#Graphs.FloydWarshallState"><code>Graphs.FloydWarshallState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FloydWarshallState{T, U}</code></pre><p>An <a href="#Graphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Floyd-Warshall shortest-paths calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/floyd-warshall.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Graph" href="#Graphs.Graph"><code>Graphs.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Graph</code></pre><p>A datastruture representing an undirected graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/Graphs.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.JohnsonState" href="#Graphs.JohnsonState"><code>Graphs.JohnsonState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct JohnsonState{T, U}</code></pre><p>An <a href="#Graphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Johnson shortest-paths calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/johnson.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.JohnsonVisitor" href="#Graphs.JohnsonVisitor"><code>Graphs.JohnsonVisitor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">type JohnsonVisitor{T&lt;:Integer} &lt;: Visitor{T}
    stack::Vector{T}
    blocked::BitVector
    blockedmap::Vector{Set{T}}
end

JohnsonVisitor(dg::::IsDirected)
</code></pre><p>Composite type that regroups the information needed for Johnson&#39;s algorithm.</p><p><code>stack</code> is the stack of visited vertices. <code>blocked</code> is a boolean for each vertex that tells whether it is blocked or not. <code>blockedmap</code> tells which vertices to unblock if the key vertex is unblocked.</p><p><code>JohnsonVisitor</code> may also be constructed directly from the directed graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L54-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.NeighComm" href="#Graphs.NeighComm"><code>Graphs.NeighComm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NeighComm{T}</code></pre><p>Type to record neighbor labels and their counts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/label_propagation.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.NotImplementedError" href="#Graphs.NotImplementedError"><code>Graphs.NotImplementedError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NotImplementedError{M}(m)</code></pre><p><code>Exception</code> thrown when a method from the <code>AbstractGraph</code> interface is not implemented by a given graph type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.YenState" href="#Graphs.YenState"><code>Graphs.YenState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct YenState{T, U}</code></pre><p>Designed for yen k-shortest-paths calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/yen.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{AbstractGraph}" href="#Base.eltype-Tuple{AbstractGraph}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eltype(g)</code></pre><p>Return the type of the graph&#39;s vertices (must be &lt;: Integer)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractGraph, Any}" href="#Base.getindex-Tuple{AbstractGraph, Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g[iter]</code></pre><p>Return the subgraph induced by <code>iter</code>. Equivalent to <a href="#Graphs.induced_subgraph-Union{Tuple{T}, Tuple{U}, Tuple{T, AbstractVector{U}}} where {U&lt;:Integer, T&lt;:AbstractGraph}"><code>induced_subgraph</code></a><code>(g, iter)[1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L683-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph" href="#Base.intersect-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersect(g, h)</code></pre><p>Return a graph with edges that are only in both graph <code>g</code> and graph <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>This function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; foreach(println, edges(intersect(g1, g2)))
Edge 1 =&gt; 2
Edge 2 =&gt; 3
Edge 3 =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L143-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.join-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph" href="#Base.join-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Base.join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">join(g, h)</code></pre><p>Return a graph that combines graphs <code>g</code> and <code>h</code> using <code>blockdiag</code> and then adds all the edges between the vertices in <code>g</code> and those in <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = join(star_graph(3), path_graph(2))
{5, 9} undirected simple Int64 graph

julia&gt; collect(edges(g))
9-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 1 =&gt; 4
 Edge 1 =&gt; 5
 Edge 2 =&gt; 4
 Edge 2 =&gt; 5
 Edge 3 =&gt; 4
 Edge 3 =&gt; 5
 Edge 4 =&gt; 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L309-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reverse(g)</code></pre><p>Return a directed graph where all edges are reversed from the original directed graph.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; foreach(println, edges(reverse(g)))
Edge 1 =&gt; 3
Edge 2 =&gt; 1
Edge 3 =&gt; 2
Edge 4 =&gt; 3
Edge 4 =&gt; 5
Edge 5 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L55-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reverse!(g)</code></pre><p>In-place reverse of a directed graph (modifies the original graph). See <a href="#Base.reverse"><code>reverse</code></a> for a non-modifying version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{AbstractEdge}" href="#Base.reverse-Tuple{AbstractEdge}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reverse(e)</code></pre><p>Create a new edge from <code>e</code> with source and destination vertices reversed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleDiGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; reverse(first(edges(g)))
Edge 2 =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L89-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{SimpleGraph, Int64}" href="#Base.size-Tuple{SimpleGraph, Int64}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(g, i)</code></pre><p>Return the number of vertices in <code>g</code> if <code>i</code>=1 or <code>i</code>=2, or <code>1</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = cycle_graph(4);

julia&gt; size(g, 1)
4

julia&gt; size(g, 2)
4

julia&gt; size(g, 3)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L452-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{AbstractGraph, Int64}" href="#Base.sum-Tuple{AbstractGraph, Int64}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sum(g, i)</code></pre><p>Return a vector of indegree (<code>i</code>=1) or outdegree (<code>i</code>=2) values for graph <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; sum(g, 2)
5-element Array{Int64,1}:
 1
 1
 2
 1
 1

julia&gt; sum(g, 1)
5-element Array{Int64,1}:
 1
 1
 1
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L418-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{AbstractGraph}" href="#Base.sum-Tuple{AbstractGraph}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sum(g)</code></pre><p>Return the number of edges in <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; sum(g)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L475-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph" href="#Base.union-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Graphs.SimpleGraphs.AbstractSimpleGraph"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">union(g, h)</code></pre><p>Return a graph that combines graphs <code>g</code> and <code>h</code> by taking the set union of all vertices and edges.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3); h = SimpleGraph(5);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 1, 3);

julia&gt; add_edge!(h, 3, 4);

julia&gt; add_edge!(h, 3, 5);

julia&gt; add_edge!(h, 4, 5);

julia&gt; f = union(g, h);

julia&gt; collect(edges(f))
5-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 3 =&gt; 4
 Edge 3 =&gt; 5
 Edge 4 =&gt; 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L253-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{Type{&lt;:AbstractGraph}}" href="#Base.zero-Tuple{Type{&lt;:AbstractGraph}}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero(G)</code></pre><p>Return a zero-vertex, zero-edge version of the graph type <code>G</code>. The fallback is defined for graph values <code>zero(g::G) = zero(G)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; zero(typeof(g))
{0, 0} directed simple Int64 graph

julia&gt; zero(g)
{0, 0} directed simple Int64 graph</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L322-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.BoundedMinkowskiCost-Tuple{AbstractVector, AbstractVector}" href="#Graphs.BoundedMinkowskiCost-Tuple{AbstractVector, AbstractVector}"><code>Graphs.BoundedMinkowskiCost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundedMinkowskiCost(μ₁, μ₂)</code></pre><p>Return value similar to <a href="#Graphs.MinkowskiCost-Tuple{AbstractVector, AbstractVector}"><code>MinkowskiCost</code></a>, but ensure costs smaller than 2τ.</p><p><strong>Optional Arguments</strong></p><p><code>p=1</code>: the p value for p-norm calculation. <code>τ=1</code>: value specifying half of the upper limit of the Minkowski cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/edit_distance.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.MinkowskiCost-Tuple{AbstractVector, AbstractVector}" href="#Graphs.MinkowskiCost-Tuple{AbstractVector, AbstractVector}"><code>Graphs.MinkowskiCost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MinkowskiCost(μ₁, μ₂; p::Real=1)</code></pre><p>For labels μ₁ on the vertices of graph G₁ and labels μ₂ on the vertices of graph G₂, compute the p-norm cost of substituting vertex u ∈ G₁ by vertex v ∈ G₂.</p><p><strong>Optional Arguments</strong></p><p><code>p=1</code>: the p value for p-norm calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/edit_distance.jl#L121-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.a_star-Union{Tuple{U}, Tuple{T}, Tuple{AbstractGraph{U}, Integer, Integer}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}, Function}} where {T, U}" href="#Graphs.a_star-Union{Tuple{U}, Tuple{T}, Tuple{AbstractGraph{U}, Integer, Integer}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, Integer, Integer, AbstractMatrix{T}, Function}} where {T, U}"><code>Graphs.a_star</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">a_star(g, s, t[, distmx][, heuristic])</code></pre><p>Return a vector of edges comprising the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to <a href="../community/#Graphs.DefaultDistance"><code>Graphs.DefaultDistance</code></a> and the heuristic is set to <code>n -&gt; 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/astar.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.add_vertices!-Tuple{AbstractGraph, Integer}" href="#Graphs.add_vertices!-Tuple{AbstractGraph, Integer}"><code>Graphs.add_vertices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_vertices!(g, n)</code></pre><p>Add <code>n</code> new vertices to the graph <code>g</code>. Return the number of vertices that were added successfully.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph()
{0, 0} undirected simple Int64 graph

julia&gt; add_vertices!(g, 2)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L28-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.all_neighbors" href="#Graphs.all_neighbors"><code>Graphs.all_neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_neighbors(g, v)</code></pre><p>Return a list of all inbound and outbound neighbors of <code>v</code> in <code>g</code>. For undirected graphs, this is equivalent to both <a href="#Graphs.outneighbors-Tuple{Any, Any}"><code>outneighbors</code></a> and <a href="#Graphs.inneighbors-Tuple{Any, Any}"><code>inneighbors</code></a>.</p><p><strong>Implementation Notes</strong></p><p>Returns a reference to the current graph&#39;s internal structures, not a copy.  Do not modify result. If the graph is modified, the behavior is undefined:  the array behind this reference may be modified too, but this is not guaranteed. </p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; using Graphs</p><p>julia&gt; g = DiGraph(3);</p><p>julia&gt; add_edge!(g, 2, 3);</p><p>julia&gt; add_edge!(g, 3, 1);</p><p>julia&gt; all_neighbors(g, 1) 1-element Array{Int64,1}:  3</p><p>julia&gt; all_neighbors(g, 2) 1-element Array{Int64,1}:  3</p><p>julia&gt; all_neighbors(g, 3) 2-element Array{Int64,1}:  1  2  ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L244-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.articulation" href="#Graphs.articulation"><code>Graphs.articulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">articulation(g)</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">articulation points</a> of a connected graph <code>g</code> and return an array containing all cut vertices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; articulation(star_graph(5))
1-element Array{Int64,1}:
 1

julia&gt; articulation(path_graph(5))
3-element Array{Int64,1}:
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/biconnectivity/articulation.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.assortativity-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T" href="#Graphs.assortativity-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.assortativity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assortativity(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Assortativity">assortativity coefficient</a> of graph <code>g</code>, defined as the Pearson correlation of excess degree between the end vertices of all the edges of the graph.</p><p>The excess degree is equal to the degree of linked vertices minus one, i.e. discounting the edge that links the pair. In directed graphs, the paired values are the out-degree of source vertices and the in-degree of destination vertices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; assortativity(star_graph(4))
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/assortativity.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.attracting_components" href="#Graphs.attracting_components"><code>Graphs.attracting_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">attracting_components(g)</code></pre><p>Return a vector of vectors of integers representing lists of attracting components in the directed graph <code>g</code>.</p><p>The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])
{5, 6} directed simple Int64 graph

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [4, 5]
 [1, 2, 3]

julia&gt; attracting_components(g)
1-element Array{Array{Int64,1},1}:
 [4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L557-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bellman_ford_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector{&lt;:Integer}}, Tuple{AbstractGraph{U}, AbstractVector{&lt;:Integer}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}" href="#Graphs.bellman_ford_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractVector{&lt;:Integer}}, Tuple{AbstractGraph{U}, AbstractVector{&lt;:Integer}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.bellman_ford_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, ss, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> (or list of sources <code>ss</code>) and all other nodes in graph <code>g</code> using the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. Return a <a href="../community/#Graphs.BellmanFordState"><code>Graphs.BellmanFordState</code></a> with relevant traversal information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/bellman-ford.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bfs_parents-Tuple{AbstractGraph, Integer}" href="#Graphs.bfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bfs_parents(g, s[; dir=:out])</code></pre><p>Perform a breadth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Performance</strong></p><p>This implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bfs.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bfs_tree-Tuple{AbstractGraph, Integer}" href="#Graphs.bfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.bfs_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bfs_tree(g, s[; dir=:out])</code></pre><p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bfs.jl#L68-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.biconnected_components" href="#Graphs.biconnected_components"><code>Graphs.biconnected_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">biconnected_components(g) -&gt; Vector{Vector{Edge{eltype(g)}}}</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">biconnected components</a> of an undirected graph <code>g</code>and return a vector of vectors containing each biconnected component.</p><p>Performance: Time complexity is <span>$\mathcal{O}(|V|)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; biconnected_components(star_graph(5))
4-element Array{Array{Graphs.SimpleGraphs.SimpleEdge,1},1}:
 [Edge 1 =&gt; 3]
 [Edge 1 =&gt; 4]
 [Edge 1 =&gt; 5]
 [Edge 1 =&gt; 2]

julia&gt; biconnected_components(cycle_graph(5))
1-element Array{Array{Graphs.SimpleGraphs.SimpleEdge,1},1}:
 [Edge 1 =&gt; 5, Edge 4 =&gt; 5, Edge 3 =&gt; 4, Edge 2 =&gt; 3, Edge 1 =&gt; 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/biconnectivity/biconnect.jl#L59-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bipartite_map-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T" href="#Graphs.bipartite_map-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.bipartite_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bipartite_map(g) -&gt; Vector{UInt8}</code></pre><p>For a bipartite graph <code>g</code>, return a vector <code>c</code> of size <span>$|V|$</span> containing the assignment of each vertex to one of the two sets (<span>$c_i == 1$</span> or <span>$c_i == 2$</span>). If <code>g</code> is not bipartite, return an empty vector.</p><p><strong>Implementation Notes</strong></p><p>Note that an empty vector does not necessarily indicate non-bipartiteness. An empty graph will return an empty vector but is bipartite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x01
 0x01

julia&gt; add_vertices!(g, 3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x02
 0x01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bipartition.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.boruvka_mst" href="#Graphs.boruvka_mst"><code>Graphs.boruvka_mst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">boruvka_mst(g, distmx = weights(g); minimize = true)</code></pre><p>Return a tuple <code>(mst, weights)</code> where <code>mst</code> is a vector of edges representing the optimum (minimum, by default) spanning tree of a connected, undirected graph <code>g</code> with optional matrix <code>distmx</code> that provides distinct edge weights, and <code>weights</code> is the sum of all the edges in the solution by using <a href="https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm">Boruvka&#39;s algorithm</a>. The algorithm requires that all edges have different weights to correctly generate a minimun/maximum spanning tree</p><p><strong>Optional Arguments</strong></p><ul><li><code>minimize=true</code>: if set to <code>false</code>, calculate the maximum spanning tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/spanningtrees/boruvka.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bridges" href="#Graphs.bridges"><code>Graphs.bridges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bridges(g)</code></pre><p>Compute the <a href="https://en.m.wikipedia.org/wiki/Bridge_(graph_theory)">bridges</a> of a connected graph <code>g</code> and return an array containing all bridges, i.e edges whose deletion increases the number of connected components of the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; bridges(star_graph(5))
8-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 1 =&gt; 4
 Edge 1 =&gt; 5

julia&gt; bridges(path_graph(5))
8-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 4 =&gt; 5
 Edge 3 =&gt; 4
 Edge 2 =&gt; 3
 Edge 1 =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/biconnectivity/bridge.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.cartesian_product-Union{Tuple{G}, Tuple{G, G}} where G&lt;:AbstractGraph" href="#Graphs.cartesian_product-Union{Tuple{G}, Tuple{G, G}} where G&lt;:AbstractGraph"><code>Graphs.cartesian_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cartesian_product(g, h)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Cartesian_product_of_graphs">cartesian product</a> of <code>g</code> and <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = cartesian_product(star_graph(3), path_graph(3))
{9, 12} undirected simple Int64 graph

julia&gt; collect(edges(g))
12-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 4
 Edge 1 =&gt; 7
 Edge 2 =&gt; 3
 Edge 2 =&gt; 5
 Edge 2 =&gt; 8
 Edge 3 =&gt; 6
 Edge 3 =&gt; 9
 Edge 4 =&gt; 5
 Edge 5 =&gt; 6
 Edge 7 =&gt; 8
 Edge 8 =&gt; 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L501-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.center-Tuple{Vector}" href="#Graphs.center-Tuple{Vector}"><code>Graphs.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center(eccentricities)
center(g, distmx=weights(g))</code></pre><p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph&#39;s radius (that is, the set of vertices with the smallest eccentricity).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; center(star_graph(5))
1-element Array{Int64,1}:
 1

julia&gt; center(path_graph(5))
1-element Array{Int64,1}:
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/distance.jl#L165-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.circuit" href="#Graphs.circuit"><code>Graphs.circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circuit{T&lt;:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T},
allcycles::Vector{Vector{T}}, vmap::Vector{T}, startnode::T = v)</code></pre><p>Return one step of the recursive version of simple cycle detection, using a DFS algorithm.</p><ul><li><code>v</code>: the vertex considered in this iteration of the DFS</li><li><code>dg</code>: the digraph from which cycles are computed</li><li><code>visitor</code>: Informations needed for the cycle computation, contains:<ul><li><code>stack</code>: the stack of parent vertices</li><li><code>blocked</code>: tells whether a vertex has already been explored or not</li><li><code>blockedmap</code>: mapping of the blocking / unblocking consequences</li></ul></li><li><code>allcycles</code>: output containing the cycles already detected</li><li><code>vmap</code>: vector map containing the link from the old to the new nodes of the directed graph</li><li><code>startnode = v</code>: optional argument giving the starting node. In the first iteration,</li></ul><p>the same as v, otherwise it should be passed.</p><p><strong>Implementation Notes</strong></p><p>Implements Johnson&#39;s CIRCUIT function. This is a recursive version. Modifies the vector of cycles, when needed.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L106-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.circuit_iter" href="#Graphs.circuit_iter"><code>Graphs.circuit_iter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circuit_iter{T&lt;:Integer}(v::T, dg::::IsDirected, vis::JohnsonVisitor{T},
vmap::Vector{T}, cycle::Channel, startnode::T = v)</code></pre><p>Execute one step of the recursive version of simple cycle detection, using a DFS algorithm. Return <code>true</code> if a circuit has been found in the current exploration.</p><p><strong>Arguments</strong></p><ul><li>v: the vertex considered in this iteration of the DFS</li><li>dg: the digraph from which cycles are computed</li><li>visitor: Informations needed for the cycle computation, contains:<ul><li>stack: the stack of parent vertices</li><li>blocked: tells whether a vertex has already been explored or not</li><li>blockedmap: mapping of the blocking / unblocking consequences</li></ul></li><li><code>vmap</code>: vector map containing the link from the old to the new nodes of the directed graph</li><li><code>cycle</code>: storage of the channel</li><li>startnode = v: optional argument giving the starting node. In the first iteration,</li></ul><p>the same as v, otherwise it should be passed.</p><p><strong>Implementation Notes</strong></p><p>Implements the CIRCUIT function from Johnson&#39;s algorithm, recursive and iterative version. Produces a cycle when needed. Can be used only inside a <code>Channel</code>.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L204-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.circuit_recursive!" href="#Graphs.circuit_recursive!"><code>Graphs.circuit_recursive!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circuit_recursive!(g, v1, v2, blocked, B, stack, cycles)</code></pre><p>Find circuits in <code>g</code> recursively starting from v1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/hawick-james.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.clique_percolation" href="#Graphs.clique_percolation"><code>Graphs.clique_percolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clique_percolation(g, k=3)</code></pre><p>Community detection using the clique percolation algorithm. Communities are potentionally overlapping. Return a vector of vectors <code>c</code> such that <code>c[i]</code> is the set of vertices in community <code>i</code>.  The parameter <code>k</code> defines the size of the clique to use in percolation.</p><p><strong>References</strong></p><ul><li><a href="https://www.nature.com/articles/nature03607">Palla G, Derenyi I, Farkas I J, et al.</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; clique_percolation(clique_graph(3, 2))
2-element Array{BitSet,1}:
 BitSet([4, 5, 6])
 BitSet([1, 2, 3])

julia&gt; clique_percolation(clique_graph(3, 2), k=2)
1-element Array{BitSet,1}:
 BitSet([1, 2, 3, 4, 5, 6])

julia&gt; clique_percolation(clique_graph(3, 2), k=4)
0-element Array{BitSet,1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/clique_percolation.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.common_neighbors-Tuple{AbstractGraph, Integer, Integer}" href="#Graphs.common_neighbors-Tuple{AbstractGraph, Integer, Integer}"><code>Graphs.common_neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">common_neighbors(g, u, v)</code></pre><p>Return the neighbors common to vertices <code>u</code> and <code>v</code> in <code>g</code>.</p><p><strong>Implementation Notes</strong></p><p>Returns a reference to the current graph&#39;s internal structures, not a copy.  Do not modify result. If the graph is modified, the behavior is undefined:  the array behind this reference may be modified too, but this is not guaranteed. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(4);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; add_edge!(g, 3, 4);

julia&gt; add_edge!(g, 4, 1);

julia&gt; add_edge!(g, 1, 3);

julia&gt; common_neighbors(g, 1, 3)
2-element Array{Int64,1}:
 2
 4

julia&gt; common_neighbors(g, 1, 4)
1-element Array{Int64,1}:
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L287-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.complement-Tuple{SimpleGraph}" href="#Graphs.complement-Tuple{SimpleGraph}"><code>Graphs.complement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">complement(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Complement_graph">graph complement</a> of a graph</p><p><strong>Implementation Notes</strong></p><p>Preserves the <code>eltype</code> of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; foreach(println, edges(complement(g)))
Edge 1 =&gt; 3
Edge 1 =&gt; 4
Edge 1 =&gt; 5
Edge 2 =&gt; 1
Edge 2 =&gt; 4
Edge 2 =&gt; 5
Edge 3 =&gt; 2
Edge 3 =&gt; 5
Edge 4 =&gt; 1
Edge 4 =&gt; 2
Edge 4 =&gt; 3
Edge 5 =&gt; 1
Edge 5 =&gt; 2
Edge 5 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.components-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.components-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">components(labels)</code></pre><p>Given a vector of component labels, return a vector of vectors representing the vertices associated with a given component id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.components_dict-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.components_dict-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.components_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">components_dict(labels)</code></pre><p>Convert an array of labels to a map of component id to vertices, and return a map with each key corresponding to a given component id and each value containing the vertices associated with that component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.compute_shifts-Tuple{Integer, AbstractArray}" href="#Graphs.compute_shifts-Tuple{Integer, AbstractArray}"><code>Graphs.compute_shifts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_shifts(n::Int, x::AbstractArray)</code></pre><p>Determine how many elements of <code>x</code> are less than <code>i</code> for all <code>i</code> in <code>1:n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L708-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.condensation" href="#Graphs.condensation"><code>Graphs.condensation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">condensation(g[, scc])</code></pre><p>Return the condensation graph of the strongly connected components <code>scc</code> in the directed graph <code>g</code>. If <code>scc</code> is missing, generate the strongly connected components first.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0])
{5, 6} directed simple Int64 graph

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [4, 5]
 [1, 2, 3]

julia&gt; foreach(println, edges(condensation(g)))
Edge 2 =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L516-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.connected_components!-Union{Tuple{T}, Tuple{AbstractVector, AbstractGraph{T}}} where T" href="#Graphs.connected_components!-Union{Tuple{T}, Tuple{AbstractVector, AbstractGraph{T}}} where T"><code>Graphs.connected_components!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connected_components!(label, g)</code></pre><p>Fill <code>label</code> with the <code>id</code> of the connected component in the undirected graph <code>g</code> to which it belongs. Return a vector representing the component assigned to each vertex. The component value is the smallest vertex ID in the component.</p><p><strong>Performance</strong></p><p>This algorithm is linear in the number of edges of the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.connected_components-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T" href="#Graphs.connected_components-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.connected_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connected_components(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">connected components</a> of an undirected graph <code>g</code> as a vector of components, with each element a vector of vertices belonging to the component.</p><p>For directed graphs, see <a href="../community/#Graphs.strongly_connected_components"><code>strongly_connected_components</code></a> and <a href="#Graphs.weakly_connected_components"><code>weakly_connected_components</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]

julia&gt; g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; connected_components(g)
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L72-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.core_number-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T" href="#Graphs.core_number-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T"><code>Graphs.core_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">core_number(g)</code></pre><p>Return the core number for each vertex in graph <code>g</code>.</p><p>A k-core is a maximal subgraph that contains vertices of degree <code>k</code> or more. The core number of a vertex is the largest value <code>k</code> of a k-core containing that vertex.</p><p><strong>Implementation Notes</strong></p><p>Not implemented for graphs with self loops.</p><p><strong>References</strong></p><ul><li>An O(m) Algorithm for Cores Decomposition of Networks,   Vladimir Batagelj and Matjaz Zaversnik, 2003.   http://arxiv.org/abs/cs.DS/0310049</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(5);

julia&gt; add_vertex!(g);

julia&gt; add_edge!(g, 5, 2);

julia&gt; core_number(g)
6-element Array{Int64,1}:
 1
 2
 2
 2
 2
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/degeneracy.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.core_periphery_deg" href="#Graphs.core_periphery_deg"><code>Graphs.core_periphery_deg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">core_periphery_deg(g)</code></pre><p>Compute the degree-based core-periphery for graph <code>g</code>. Return the vertex assignments (<code>1</code> for core and <code>2</code> for periphery) for each node in <code>g</code>.</p><p>References:     <a href="http://arxiv.org/abs/1102.5511">Lip</a>)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; core_periphery_deg(star_graph(5))
5-element Array{Int64,1}:
 1
 2
 2
 2
 2

julia&gt; core_periphery_deg(path_graph(3))
3-element Array{Int64,1}:
 2
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/core-periphery.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.crosspath" href="#Graphs.crosspath"><code>Graphs.crosspath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crosspath(len::Integer, g::Graph)</code></pre><p>Return a graph that duplicates <code>g</code> <code>len</code> times and connects each vertex with its copies in a path.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = crosspath(3, path_graph(3))
{9, 12} undirected simple Int64 graph

julia&gt; collect(edges(g))
12-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 4
 Edge 2 =&gt; 3
 Edge 2 =&gt; 5
 Edge 3 =&gt; 6
 Edge 4 =&gt; 5
 Edge 4 =&gt; 7
 Edge 5 =&gt; 6
 Edge 5 =&gt; 8
 Edge 6 =&gt; 9
 Edge 7 =&gt; 8
 Edge 8 =&gt; 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L350-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.cycle_basis" href="#Graphs.cycle_basis"><code>Graphs.cycle_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cycle_basis(g, root=nothing)</code></pre><p>Return a list of cycles which form a basis for cycles of the undirected graph <code>g</code>, optionally starting at node <code>root</code>.</p><p>A basis for cycles of a network is a minimal collection of cycles such that any cycle in the network can be written as a sum of cycles in the basis.  Here summation of cycles is defined as &quot;exclusive or&quot; of the edges. Cycle bases are useful, e.g. when deriving equations for electric circuits using Kirchhoff&#39;s Laws.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; elist = [(1,2),(2,3),(2,4),(3,4),(4,1),(1,5)];

julia&gt; g = SimpleGraph(SimpleEdge.(elist));

julia&gt; cycle_basis(g)
2-element Array{Array{Int64,1},1}:
 [2, 3, 4]
 [2, 1, 3]</code></pre><p><strong>References</strong></p><ul><li>Paton, K. An algorithm for finding a fundamental set of cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518. [https://dl.acm.org/citation.cfm?id=363232]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/basis.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.deepcopy_adjlist-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T" href="#Graphs.deepcopy_adjlist-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T"><code>Graphs.deepcopy_adjlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deepcopy_adjlist(adjlist::Vector{Vector{T}})</code></pre><p>Internal utility function for copying adjacency lists. On adjacency lists this function is more efficient than <code>deepcopy</code> for two reasons:</p><ul><li>As of Julia v1.0.2, <code>deepcopy</code> is not typestable.</li><li><code>deepcopy</code> needs to track all references when traversing a recursive data structure   in order to ensure that references to the same location do need get assigned to   different locations in the copy. Because we can assume that all lists in our   adjacency list are different, we don&#39;t need to keep track of them.</li></ul><p>If <code>T</code> is not a bitstype (e.g. <code>BigInt</code>), we use the standard <code>deepcopy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L247-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.degree" href="#Graphs.degree"><code>Graphs.degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">degree(g[, v])</code></pre><p>Return a vector corresponding to the number of edges which start or end at each vertex in graph <code>g</code>. If <code>v</code> is specified, only return degrees for vertices in <code>v</code>. For directed graphs, this value equals the incoming plus outgoing edges. For undirected graphs, it equals the connected edges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = DiGraph(3);

julia&gt; add_edge!(g, 2, 3);

julia&gt; add_edge!(g, 3, 1);

julia&gt; degree(g)
3-element Array{Int64,1}:
 1
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L99-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.degree_histogram-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T" href="#Graphs.degree_histogram-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.degree_histogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree_histogram(g, degfn=degree)</code></pre><p>Return a <code>Dict</code> with values representing the number of vertices that have degree represented by the key.</p><p>Degree function (for example, <a href="#Graphs.indegree-Tuple{AbstractGraph, Integer}"><code>indegree</code></a> or <a href="#Graphs.outdegree-Tuple{AbstractGraph, Integer}"><code>outdegree</code></a>) may be specified by overriding <code>degfn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L188-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.density" href="#Graphs.density"><code>Graphs.density</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">density(g)</code></pre><p>Return the density of <code>g</code>. Density is defined as the ratio of the number of actual edges to the number of possible edges (<span>$|V|×(|V|-1)$</span> for directed graphs and <span>$\frac{|V|×(|V|-1)}{2}$</span> for undirected graphs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L374-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.desopo_pape_shortest_paths-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T&lt;:Real" href="#Graphs.desopo_pape_shortest_paths-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.desopo_pape_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">desopo_pape_shortest_paths(g, src, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>src</code> and all other nodes in graph <code>g</code> using the <a href="http://web.mit.edu/dimitrib/www/SLF.pdf">D&#39;Esopo-Pape algorithm</a>. Return a <a href="../community/#Graphs.DEsopoPapeState"><code>Graphs.DEsopoPapeState</code></a> with relevant traversal information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; ds = desopo_pape_shortest_paths(cycle_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 2

julia&gt; ds = desopo_pape_shortest_paths(path_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/desopo-pape.jl#L11-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dfs_parents-Tuple{AbstractGraph, Integer}" href="#Graphs.dfs_parents-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_parents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dfs_parents(g, s[; dir=:out])</code></pre><p>Perform a depth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Implementation Notes</strong></p><p>This version of DFS is iterative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/dfs.jl#L92-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dfs_tree-Tuple{AbstractGraph, Integer}" href="#Graphs.dfs_tree-Tuple{AbstractGraph, Integer}"><code>Graphs.dfs_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dfs_tree(g, s)</code></pre><p>Return an ordered vector of vertices representing a directed acyclic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/dfs.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.diameter-Tuple{Vector}" href="#Graphs.diameter-Tuple{Vector}"><code>Graphs.diameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diameter(eccentricities)
diameter(g, distmx=weights(g))</code></pre><p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the maximum eccentricity of the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; diameter(star_graph(5))
2

julia&gt; diameter(path_graph(5))
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/distance.jl#L87-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.difference-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph" href="#Graphs.difference-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Graphs.difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">difference(g, h)</code></pre><p>Return a graph with edges in graph <code>g</code> that are not in graph <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Note that this function may produce a graph with 0-degree vertices. Preserves the <code>eltype</code> of the input graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; foreach(println, edges(difference(g1, g2)))
Edge 3 =&gt; 4
Edge 4 =&gt; 5
Edge 5 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L175-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.diffusion-Union{Tuple{T}, Tuple{AbstractGraph{T}, Real, Integer}} where T" href="#Graphs.diffusion-Union{Tuple{T}, Tuple{AbstractGraph{T}, Real, Integer}} where T"><code>Graphs.diffusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diffusion(g, p, n)</code></pre><p>Run diffusion simulation on <code>g</code> for <code>n</code> steps with spread probabilities based on <code>p</code>. Return a vector with the set of new vertices reached at each step of the simulation.</p><p><strong>Optional Arguments</strong></p><ul><li><code>initial_infections=sample(vertices(g), 1)</code>: A list of vertices that</li></ul><p>are infected at the start of the simulation.</p><ul><li><code>watch=Vector()</code>: While simulation is always run on the full graph,</li></ul><p>specifying <code>watch</code> limits reporting to a specific set of vertices reached during the simulation. If left empty, all vertices will be watched.</p><ul><li><code>normalize=false</code>: if <code>false</code>, set the probability of spread from a vertex <span>$i$</span> to</li></ul><p>each of the outneighbors of <span>$i$</span> to <span>$p$</span>. If <code>true</code>, set the probability of spread from a vertex <span>$i$</span> to each of the <code>outneighbors</code> of <span>$i$</span> to <span>$\frac{p}{outdegreee(g, i)}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/diffusion.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.diffusion_rate-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.diffusion_rate-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.diffusion_rate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diffusion_rate(results)
diffusion_rate(g, p, n; ...)</code></pre><p>Given the results of a <code>diffusion</code> output or the parameters to the <code>diffusion</code> simulation itself, (run and) return the rate of diffusion as a vector representing the cumulative number of vertices infected at each simulation step, restricted to vertices included in <code>watch</code>, if specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/diffusion.jl#L77-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dijkstra_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, Vector{U}}, Tuple{AbstractGraph, Vector{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}" href="#Graphs.dijkstra_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, Vector{U}}, Tuple{AbstractGraph, Vector{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.dijkstra_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dijkstra_shortest_paths(g, srcs, distmx=weights(g));</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> on a graph, computing shortest distances between <code>srcs</code> and all other vertices. Return a <a href="../community/#Graphs.DijkstraState"><code>Graphs.DijkstraState</code></a> that contains various traversal information.</p><p><strong>Optional Arguments</strong></p><ul><li><code>allpaths=false</code>: If true, returns a <a href="../community/#Graphs.DijkstraState"><code>Graphs.DijkstraState</code></a> that keeps track of all</li></ul><p>predecessors of a given vertex.</p><p><strong>Performance</strong></p><p>If using a sparse matrix for <code>distmx</code>, you <em>may</em> achieve better performance by passing in a transpose of its sparse transpose. That is, assuming <code>D</code> is the sparse distance matrix:</p><pre><code class="language-none">D = transpose(sparse(transpose(D)))</code></pre><p>Be aware that realizing the sparse transpose of <code>D</code> incurs a heavy one-time penalty, so this strategy should only be used when multiple calls to <code>dijkstra_shortest_paths</code> with the distance matrix are planned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; ds = dijkstra_shortest_paths(cycle_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 2

julia&gt; ds = dijkstra_shortest_paths(path_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/dijkstra.jl#L14-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeDominatingSet}} where T&lt;:Integer" href="#Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeDominatingSet}} where T&lt;:Integer"><code>Graphs.dominating_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dominating_set(g, DegreeDominatingSet())</code></pre><p>Obtain a <a href="https://en.wikipedia.org/wiki/Dominating_set">dominating set</a> using a greedy heuristic.</p><p><strong>Implementation Notes</strong></p><p>A vertex is said to be dominated if it is in the dominating set or adjacent to a vertex  in the dominating set. Initialise the dominating set to an empty set and iteratively choose the vertex that would  dominate the most undominated vertices.</p><p><strong>Performance</strong></p><p>Runtime: <span>$\mathcal{O}((|V|+|E|)*log(|V|))$</span> Memory: <span>$\mathcal{O}(|V|)$</span> Approximation Factor: <code>ln(maximum(degree(g)))+2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/dominatingset/degree_dom_set.jl#L33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MinimalDominatingSet}} where T&lt;:Integer" href="#Graphs.dominating_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MinimalDominatingSet}} where T&lt;:Integer"><code>Graphs.dominating_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dominating_set(g, MinimalDominatingSet(); seed=-1)</code></pre><p>Find a set of vertices that consitute a dominating set (all vertices in <code>g</code> are either adjacent to a vertex  in the set or is a vertex in the set) and it is not possible to delete a vertex from the set  without sacrificing the dominating property.</p><p><strong>Implementation Notes</strong></p><p>Initially, every vertex is in the dominating set. In some random order, we check if the removal of a vertex from the set will destroy the  dominating property. If no, the vertex is removed from the dominating set.</p><p><strong>Performance</strong></p><p>Runtime: <span>$\mathcal{O}(|V|+|E|)$</span> Memory: <span>$\mathcal{O}(|V|)$</span></p><p><strong>Optional Arguments</strong></p><ul><li>If <code>seed &gt;= 0</code>, a random generator is seeded with this value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/dominatingset/minimal_dom_set.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dst-Tuple{AbstractEdge}" href="#Graphs.dst-Tuple{AbstractEdge}"><code>Graphs.dst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dst(e)</code></pre><p>Return the destination vertex of edge <code>e</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; dst(first(edges(g)))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L67-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.eccentricity-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T&lt;:Real" href="#Graphs.eccentricity-Union{Tuple{T}, Tuple{AbstractGraph, Integer}, Tuple{AbstractGraph, Integer, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.eccentricity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eccentricity(g[, v][, distmx])
eccentricity(g[, vs][, distmx])</code></pre><p>Return the eccentricity[ies] of a vertex / vertex list <code>v</code> or a set of vertices <code>vs</code> defaulting to the entire graph. An optional matrix of edge distances may be supplied; if missing, edge distances default to <code>1</code>.</p><p>The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.</p><p>The output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.</p><p><strong>Performance</strong></p><p>Because this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.</p><p><strong>Implementation Notes</strong></p><p>The eccentricity vector returned by <code>eccentricity()</code> may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.</p><p>An infinite path length is represented by the <code>typemax</code> of the distance matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; eccentricity(g, 1)
2

julia&gt; eccentricity(g, [1; 2])
2-element Array{Int64,1}:
 2
 1

julia&gt; eccentricity(g, [1; 2], [0 2 0; 0.5 0 0.5; 0 2 0])
2-element Array{Float64,1}:
 2.5
 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/distance.jl#L24-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edges-Tuple{Any}" href="#Graphs.edges-Tuple{Any}"><code>Graphs.edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">edges(g)</code></pre><p>Return (an iterator to or collection of) the edges of a graph. For <code>AbstractSimpleGraph</code>s it returns a <code>SimpleEdgeIter</code>. The expressions <code>e in edges(g)</code> and <code>e ∈ edges(ga)</code> evaluate as calls to <a href="#Graphs.has_edge-Tuple{Any, Any, Any}"><code>has_edge</code></a>.</p><p><strong>Implementation Notes</strong></p><p>A returned iterator is valid for one pass over the edges, and is invalidated by changes to <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(3);

julia&gt; collect(edges(g))
2-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L183-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edgetype-Tuple{AbstractGraph}" href="#Graphs.edgetype-Tuple{AbstractGraph}"><code>Graphs.edgetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">edgetype(g)</code></pre><p>Return the type of graph <code>g</code>&#39;s edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.edit_distance-Tuple{AbstractGraph, AbstractGraph}" href="#Graphs.edit_distance-Tuple{AbstractGraph, AbstractGraph}"><code>Graphs.edit_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">edit_distance(G₁::AbstractGraph, G₂::AbstractGraph)</code></pre><p>Compute the edit distance between graphs <code>G₁</code> and <code>G₂</code>. Return the minimum edit cost and edit path to transform graph <code>G₁</code> into graph <code>G₂</code><code>. An edit path consists of a sequence of pairs of vertices</code><code>(u,v) ∈ [0,|G₁|] × [0,|G₂|]</code>` representing vertex operations:</p><ul><li><span>$(0,v)$</span>: insertion of vertex <span>$v ∈ G₂$</span></li><li><span>$(u,0)$</span>: deletion of vertex <span>$u ∈ G₁$</span></li><li><span>$(u&gt;0,v&gt;0)$</span>: substitution of vertex <span>$u ∈ G₁$</span> by vertex <span>$v ∈ G₂$</span></li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>insert_cost::Function=v-&gt;1.0</code></li><li><code>delete_cost::Function=u-&gt;1.0</code></li><li><code>subst_cost::Function=(u,v)-&gt;0.5</code></li></ul><p>By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels μ₁ (for G₁) and μ₂ (for G₂) in order to further guide the search, for example:</p><pre><code class="language-none">edit_distance(G₁, G₂, subst_cost=MinkowskiCost(μ₁, μ₂))</code></pre><ul><li><code>heuristic::Function=DefaultEditHeuristic</code>: a custom heuristic provided to the A*</li></ul><p>search in case the default heuristic is not satisfactory.</p><p><strong>Performance</strong></p><ul><li>Given two graphs <span>$|G₁| &lt; |G₂|$</span>, <code>edit_distance(G₁, G₂)</code> is faster to</li></ul><p>compute than <code>edit_distance(G₂, G₁)</code>. Consider swapping the arguments if involved costs are equivalent.</p><ul><li>The use of simple Minkowski costs can improve performance considerably.</li><li>Exploit vertex attributes when designing operation costs.</li></ul><p><strong>References</strong></p><ul><li>RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)</li></ul><p><strong>Author</strong></p><ul><li>Júlio Hoffimann Mendes (juliohm@stanford.edu)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; edit_distance(g1, g2)
(3.5, Tuple[(1, 2), (2, 1), (3, 0), (4, 3), (5, 0)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/edit_distance.jl#L1-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.egonet-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Integer}, Tuple{AbstractGraph{T}, Integer, Integer, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}" href="#Graphs.egonet-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Integer}, Tuple{AbstractGraph{T}, Integer, Integer, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}"><code>Graphs.egonet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">egonet(g, v, d, distmx=weights(g))</code></pre><p>Return the subgraph of <code>g</code> induced by the neighbors of <code>v</code> up to distance <code>d</code>, using weights (optionally) provided by <code>distmx</code>. This is equivalent to <a href="#Graphs.induced_subgraph-Union{Tuple{T}, Tuple{U}, Tuple{T, AbstractVector{U}}} where {U&lt;:Integer, T&lt;:AbstractGraph}"><code>induced_subgraph</code></a><code>(g, neighborhood(g, v, d, dir=dir))[1].</code></p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: if <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> (i.e. <code>:in</code> or <code>:out</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L692-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.enumerate_paths-Tuple{Graphs.AbstractPathState, AbstractVector{&lt;:Integer}}" href="#Graphs.enumerate_paths-Tuple{Graphs.AbstractPathState, AbstractVector{&lt;:Integer}}"><code>Graphs.enumerate_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enumerate_paths(state[, vs])</code></pre><p>Given a path state <code>state</code> of type <code>AbstractPathState</code>, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p><strong>Implementation Notes</strong></p><p>For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: <code>enumerate_paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>enumerate_paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>enumerate_paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/bellman-ford.jl#L92-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.filter_non_term_leaves!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer" href="#Graphs.filter_non_term_leaves!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.filter_non_term_leaves!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filter_non_term_leaves!(g, term_vert)</code></pre><p>Remove edges of <code>g</code> so that all non-isolated leaves of <code>g</code> are in the set <code>term_vert</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/steinertree/steiner_tree.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.findall!-Union{Tuple{T}, Tuple{Union{BitVector, Vector{Bool}}, Vector{T}}} where T&lt;:Integer" href="#Graphs.findall!-Union{Tuple{T}, Tuple{Union{BitVector, Vector{Bool}}, Vector{T}}} where T&lt;:Integer"><code>Graphs.findall!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findall!(A, B)</code></pre><p>Set the <code>B[1:|I|]</code> to <code>I</code> where <code>I</code> is the set of indices <code>A[I]</code> returns true. </p><p>Assumes <code>length(B) &gt;= |I|</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L60-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.floyd_warshall_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}" href="#Graphs.floyd_warshall_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.floyd_warshall_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">floyd_warshall_shortest_paths(g, distmx=weights(g))</code></pre><p>Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>. Return a <a href="../community/#Graphs.FloydWarshallState"><code>Graphs.FloydWarshallState</code></a> with relevant traversal information.</p><p><strong>Performance</strong></p><p>Space complexity is on the order of <span>$\mathcal{O}(|V|^2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/floyd-warshall.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T" href="#Graphs.gdistances!-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any, Any}} where T"><code>Graphs.gdistances!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gdistances!(g, source, dists; sort_alg=QuickSort)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from source vertex (or collection of vertices) <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>  filled with <code>typemax(T)</code>. Return <code>dists</code>.</p><p>For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bfs.jl#L78-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T" href="#Graphs.gdistances-Union{Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.gdistances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gdistances(g, source; sort_alg=QuickSort)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bfs.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.global_clustering_coefficient-Tuple{AbstractGraph}" href="#Graphs.global_clustering_coefficient-Tuple{AbstractGraph}"><code>Graphs.global_clustering_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">global_clustering_coefficient(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">global clustering coefficient</a> of graph <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; global_clustering_coefficient(star_graph(4))
0.0

julia&gt; global_clustering_coefficient(smallgraph(:housex))
0.7894736842105263</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/clustering.jl#L126-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.greedy_contiguous_partition-Union{Tuple{U}, Tuple{Vector{&lt;:Integer}, Integer}, Tuple{Vector{&lt;:Integer}, Integer, U}} where U&lt;:Integer" href="#Graphs.greedy_contiguous_partition-Union{Tuple{U}, Tuple{Vector{&lt;:Integer}, Integer}, Tuple{Vector{&lt;:Integer}, Integer, U}} where U&lt;:Integer"><code>Graphs.greedy_contiguous_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greedy_contiguous_partition(weight, required_partitions, num_items=length(weight))</code></pre><p>Partition <code>1:num_items</code> into atmost <code>required_partitions</code> number of contiguous partitions with  the objective of minimising the largest partition. The size of a partition is equal to the num of the weight of its elements. <code>weight[i] &gt; 0</code>.</p><p><strong>Performance</strong></p><p>Time: O(num<em>items+required</em>partitions) Requires only one iteration over <code>weight</code> but may not output the optimal partition.</p><p><strong>Implementation Notes</strong></p><p><code>Balance(wt, left, right, n_items, n_part) =  max(sum(wt[left:right])*(n_part-1), sum(wt[right+1:n_items]))</code>. Find <code>right</code> that minimises <code>Balance(weight, 1, right, num_items, required_partitions)</code>. Set the first partition as <code>1:right</code>. Repeat on indices <code>right+1:num_items</code> and one less partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L102-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_edge-Tuple{Any, Any, Any}" href="#Graphs.has_edge-Tuple{Any, Any, Any}"><code>Graphs.has_edge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_edge(g, s, d)</code></pre><p>Return true if the graph <code>g</code> has an edge from node <code>s</code> to node <code>d</code>.</p><p>An optional <code>has_edge(g, e)</code> can be implemented to check if an edge belongs to a graph, including any data other than source and destination node.</p><p><code>e ∈ edges(g)</code> or <code>e ∈ edges(g)</code> evaluate as calls to <code>has_edge</code>, c.f. <a href="#Graphs.edges-Tuple{Any}"><code>edges</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleDiGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; has_edge(g, 1, 2)
true

julia&gt; has_edge(g, 2, 1)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L250-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_negative_edge_cycle_spfa-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}" href="#Graphs.has_negative_edge_cycle_spfa-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.has_negative_edge_cycle_spfa</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function which returns true if there is any negative weight cycle in the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = complete_graph(3);

julia&gt; d = [1 -3 1; -3 1 1; 1 1 1];

julia&gt; has_negative_edge_cycle_spfa(g, d)
true

julia&gt; g = complete_graph(4);

julia&gt; d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];

julia&gt; has_negative_edge_cycle_spfa(g, d);
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/spfa.jl#L93-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_path-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Integer}} where T" href="#Graphs.has_path-Union{Tuple{T}, Tuple{AbstractGraph{T}, Integer, Integer}} where T"><code>Graphs.has_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())</code></pre><p>Return <code>true</code> if there is a path from <code>u</code> to <code>v</code> in <code>g</code> (while avoiding vertices in <code>exclude_vertices</code>) or <code>u == v</code>. Return false if there is no such path or if <code>u</code> or <code>v</code> is in <code>excluded_vertices</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bfs.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_self_loops-Tuple{AbstractGraph}" href="#Graphs.has_self_loops-Tuple{AbstractGraph}"><code>Graphs.has_self_loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_self_loops(g)</code></pre><p>Return true if <code>g</code> has any self loops.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; has_self_loops(g)
false

julia&gt; add_edge!(g, 1, 1);

julia&gt; has_self_loops(g)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L326-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_vertex-Tuple{Any, Any}" href="#Graphs.has_vertex-Tuple{Any, Any}"><code>Graphs.has_vertex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_vertex(g, v)</code></pre><p>Return true if <code>v</code> is a vertex of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; has_vertex(SimpleGraph(2), 1)
true

julia&gt; has_vertex(SimpleGraph(2), 3)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L232-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.indegree-Tuple{AbstractGraph, Integer}" href="#Graphs.indegree-Tuple{AbstractGraph, Integer}"><code>Graphs.indegree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">indegree(g[, v])</code></pre><p>Return a vector corresponding to the number of edges which end at each vertex in graph <code>g</code>. If <code>v</code> is specified, only return degrees for vertices in <code>v</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = DiGraph(3);

julia&gt; add_edge!(g, 2, 3);

julia&gt; add_edge!(g, 3, 1);

julia&gt; indegree(g)
3-element Array{Int64,1}:
 1
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L47-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeIndependentSet}} where T&lt;:Integer" href="#Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeIndependentSet}} where T&lt;:Integer"><code>Graphs.independent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">independent_set(g, DegreeIndependentSet())</code></pre><p>Obtain an <a href="https://en.wikipedia.org/wiki/Independent_set_(graph_theory)">independent set</a> of <code>g</code> using a greedy heuristic based on the degree of the vertices.</p><p><strong>Implementation Notes</strong></p><p>A vertex is said to be valid if it is not in the independent set or adjacent to any vertex in the independent set. Initilalise the independent set to an empty set and iteratively choose the vertex that is  adjacent to the fewest valid vertices in the independent set until all vertices are invalid.</p><p><strong>Performance</strong></p><p>Runtime: O((|V|+|E|)*log(|V|)) Memory: O(|V|)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/independentset/degree_ind_set.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MaximalIndependentSet}} where T&lt;:Integer" href="#Graphs.independent_set-Union{Tuple{T}, Tuple{AbstractGraph{T}, MaximalIndependentSet}} where T&lt;:Integer"><code>Graphs.independent_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">independent_set(g, MaximalIndependentSet(); seed=-1)</code></pre><p>Find a random set of vertices that are independent (no two vertices are adjacent to each other) and  it is not possible to insert a vertex into the set without sacrificing the independence property.</p><p><strong>Implementation Notes</strong></p><p>Performs <a href="https://en.wikipedia.org/wiki/Maximal_independent_set#Sequential_algorithm">Approximate Maximum Independent Set</a> once. Returns a vector of vertices representing the vertices in the independent set.</p><p><strong>Performance</strong></p><p>Runtime: O(|V|+|E|) Memory: O(|V|) Approximation Factor: maximum(degree(g))+1</p><p><strong>Optional Arguments</strong></p><ul><li>If <code>seed &gt;= 0</code>, a random generator is seeded with this value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/independentset/maximal_ind_set.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.induced_subgraph-Union{Tuple{T}, Tuple{U}, Tuple{T, AbstractVector{U}}} where {U&lt;:Integer, T&lt;:AbstractGraph}" href="#Graphs.induced_subgraph-Union{Tuple{T}, Tuple{U}, Tuple{T, AbstractVector{U}}} where {U&lt;:Integer, T&lt;:AbstractGraph}"><code>Graphs.induced_subgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">induced_subgraph(g, vlist)
induced_subgraph(g, elist)</code></pre><p>Return the subgraph of <code>g</code> induced by the vertices in  <code>vlist</code> or edges in <code>elist</code> along with a vector mapping the new vertices to the old ones (the  vertex <code>i</code> in the subgraph corresponds to the vertex <code>vmap[i]</code> in <code>g</code>.)</p><p>The returned graph has <code>length(vlist)</code> vertices, with the new vertex <code>i</code> corresponding to the vertex of the original graph in the <code>i</code>-th position of <code>vlist</code>.</p><p><strong>Usage Examples</strong></p><pre><code class="language-doctestjl">julia&gt; g = complete_graph(10)

julia&gt; sg, vmap = induced_subgraph(g, 5:8)

julia&gt; @assert g[5:8] == sg

julia&gt; @assert nv(sg) == 4

julia&gt; @assert ne(sg) == 6

julia&gt; @assert vm[4] == 8

julia&gt; sg, vmap = induced_subgraph(g, [2,8,3,4])

julia&gt; @assert sg == g[[2,8,3,4]]

julia&gt; elist = [Edge(1,2), Edge(3,4), Edge(4,8)]

julia&gt; sg, vmap = induced_subgraph(g, elist)

julia&gt; @assert sg == g[elist]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L602-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.inneighbors-Tuple{Any, Any}" href="#Graphs.inneighbors-Tuple{Any, Any}"><code>Graphs.inneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inneighbors(g, v)</code></pre><p>Return a list of all neighbors connected to vertex <code>v</code> by an incoming edge.</p><p><strong>Implementation Notes</strong></p><p>Returns a reference to the current graph&#39;s internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; inneighbors(g, 4)
2-element Array{Int64,1}:
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L279-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.insorted-Tuple{Any, Any}" href="#Graphs.insorted-Tuple{Any, Any}"><code>Graphs.insorted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insorted(item, collection)</code></pre><p>Return true if <code>item</code> is in sorted collection <code>collection</code>.</p><p><strong>Implementation Notes</strong></p><p>Does not verify that <code>collection</code> is sorted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L47-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_bipartite-Tuple{AbstractGraph}" href="#Graphs.is_bipartite-Tuple{AbstractGraph}"><code>Graphs.is_bipartite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_bipartite(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; is_bipartite(g)
true

julia&gt; add_edge!(g, 1, 3);

julia&gt; is_bipartite(g)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bipartition.jl#L67-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_connected-Tuple{AbstractGraph}" href="#Graphs.is_connected-Tuple{AbstractGraph}"><code>Graphs.is_connected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_connected(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is connected. For directed graphs, return <code>true</code> if graph <code>g</code> is weakly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; is_connected(g)
true

julia&gt; g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; is_connected(g)
false

julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_connected(g)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L105-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_cyclic" href="#Graphs.is_cyclic"><code>Graphs.is_cyclic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_cyclic(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> contains a cycle.</p><p><strong>Implementation Notes</strong></p><p>Uses DFS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/dfs.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_directed-Tuple{G} where G" href="#Graphs.is_directed-Tuple{G} where G"><code>Graphs.is_directed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_directed(G)</code></pre><p>Return <code>true</code> if the graph type <code>G</code> is a directed graph; <code>false</code> otherwise. New graph types must implement <code>is_directed(::Type{&lt;:G})</code>. The method can also be called with <code>is_directed(g::G)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; is_directed(SimpleGraph(2))
false

julia&gt; is_directed(SimpleGraph)
false

julia&gt; is_directed(SimpleDiGraph(2))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L209-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_ordered-Tuple{AbstractEdge}" href="#Graphs.is_ordered-Tuple{AbstractEdge}"><code>Graphs.is_ordered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_ordered(e)</code></pre><p>Return true if the source vertex of edge <code>e</code> is less than or equal to the destination vertex.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = DiGraph(2);

julia&gt; add_edge!(g, 2, 1);

julia&gt; is_ordered(first(edges(g)))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L8-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_strongly_connected" href="#Graphs.is_strongly_connected"><code>Graphs.is_strongly_connected</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_strongly_connected(g)</code></pre><p>Return <code>true</code> if directed graph <code>g</code> is strongly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_strongly_connected(g)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L463-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_weakly_connected-Tuple{Any}" href="#Graphs.is_weakly_connected-Tuple{Any}"><code>Graphs.is_weakly_connected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_weakly_connected(g)</code></pre><p>Return <code>true</code> if the graph <code>g</code> is weakly connected. If <code>g</code> is undirected, this function is equivalent to <a href="../community/#Graphs.is_connected-Tuple{AbstractGraph}"><code>is_connected(g)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_weakly_connected(g)
true

julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; is_connected(g)
true

julia&gt; is_strongly_connected(g)
false

julia&gt; is_weakly_connected(g)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L152-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.isbounded-Tuple{Integer}" href="#Graphs.isbounded-Tuple{Integer}"><code>Graphs.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(n)</code></pre><p>Returns true if <code>typemax(n)</code> of an integer <code>n</code> exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.isbounded-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.isbounded-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.isbounded</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isbounded(T)</code></pre><p>Returns true if <code>typemax(T)</code> of a type <code>T &lt;: Integer</code> exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.isgraphical-Tuple{Vector{&lt;:Integer}}" href="#Graphs.isgraphical-Tuple{Vector{&lt;:Integer}}"><code>Graphs.isgraphical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isgraphical(degs)</code></pre><p>Return true if the degree sequence <code>degs</code> is graphical. A sequence of integers is called graphical, if there exists a graph where the degrees of its vertices form that same sequence.</p><p><strong>Performance</strong></p><p>Time complexity: <span>$\mathcal{O}(|degs|*\log(|degs|))$</span>.</p><p><strong>Implementation Notes</strong></p><p>According to Erdös-Gallai theorem, a degree sequence <span>$\{d_1, ...,d_n\}$</span> (sorted in descending order) is graphic iff the sum of vertex degrees is even and the sequence obeys the property -</p><p class="math-container">\[\sum_{i=1}^{r} d_i \leq r(r-1) + \sum_{i=r+1}^n min(r,d_i)\]</p><p>for each integer r &lt;= n-1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L702-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.itercycles" href="#Graphs.itercycles"><code>Graphs.itercycles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">itercycles(dg::::IsDirected, cycle::Channel)</code></pre><p>Compute all cycles of the given directed graph, using Johnson&#39;s algorithm.</p><p><strong>Implementation Notes</strong></p><p>Iterative version of the algorithm, using <code>Channel</code>s to stop the exploration after a given number of cycles.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L262-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.johnson_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}" href="#Graphs.johnson_shortest_paths-Union{Tuple{AbstractGraph{U}}, Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.johnson_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">johnson_shortest_paths(g, distmx=weights(g))</code></pre><p>Use the <a href="https://en.wikipedia.org/wiki/Johnson%27s_algorithm">Johnson algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>.</p><p>Return a <a href="#Graphs.JohnsonState"><code>Graphs.JohnsonState</code></a> with relevant traversal information.</p><p><strong>Performance</strong></p><p>Complexity: O(|V|*|E|)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/johnson.jl#L12-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.k_core" href="#Graphs.k_core"><code>Graphs.k_core</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">k_core(g[, k]; corenum=core_number(g))</code></pre><p>Return a vector of vertices in the k-core of graph <code>g</code>. If <code>k</code> is not specified, return the core with the largest degree.</p><p>A k-core is a maximal subgraph that contains vertices of degree <code>k</code> or more.</p><p><strong>Implementation Notes</strong></p><p>Not implemented for graphs with self loops.</p><p><strong>References</strong></p><ul><li>An O(m) Algorithm for Cores Decomposition of Networks,   Vladimir Batagelj and Matjaz Zaversnik, 2003.   http://arxiv.org/abs/cs.DS/0310049</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(5);

julia&gt; add_vertex!(g);

julia&gt; add_edge!(g, 5, 2);

julia&gt; k_core(g, 1)
5-element Array{Int64,1}:
 1
 2
 3
 4
 5

julia&gt; k_core(g, 2)
4-element Array{Int64,1}:
 2
 3
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/degeneracy.jl#L114-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.k_corona-Tuple{AbstractGraph, Any}" href="#Graphs.k_corona-Tuple{AbstractGraph, Any}"><code>Graphs.k_corona</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">k_corona(g, k; corenum=core_number(g))</code></pre><p>Return a vector of vertices in the k-corona of <code>g</code>.</p><p>The k-corona is the subgraph of vertices in the <a href="#Graphs.k_core"><code>k-core</code></a> which have exactly <code>k</code> neighbors in the k-core.</p><p><strong>Implementation Notes</strong></p><p>Not implemented for graphs with parallel edges or self loops.</p><p><strong>References</strong></p><ul><li>k-core (bootstrap) percolation on complex networks:  Critical phenomena and nonlocal effects,  A. V. Goltsev, S. N. Dorogovtsev, and J. F. F. Mendes,  Phys. Rev. E 73, 056101 (2006)  http://link.aps.org/doi/10.1103/PhysRevE.73.056101</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(5);

julia&gt; add_vertex!(g);

julia&gt; add_edge!(g, 5, 2);

julia&gt; k_corona(g, 0)
1-element Array{Int64,1}:
 6

julia&gt; k_corona(g, 1)
1-element Array{Int64,1}:
 1

julia&gt; k_corona(g, 2)
4-element Array{Int64,1}:
 2
 3
 4
 5

julia&gt; k_corona(g, 3)
0-element Array{Int64,1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/degeneracy.jl#L278-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.k_crust" href="#Graphs.k_crust"><code>Graphs.k_crust</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">k_crust(g[, k]; corenum=core_number(g))</code></pre><p>Return a vector of vertices in the k-crust of <code>g</code>. If <code>k</code> is not specified, return the crust of the core with the largest degree.</p><p>The k-crust is the graph <code>g</code> with the <a href="#Graphs.k_core"><code>k-core</code></a> removed.</p><p><strong>Implementation Notes</strong></p><p>This definition of k-crust is different than the definition in References. The k-crust in References is equivalent to the <code>k+1</code> crust of this algorithm.</p><p>Not implemented for graphs with self loops.</p><p><strong>References</strong></p><ul><li>A model of Internet topology using k-shell decomposition  Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,  and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154  http://www.pnas.org/content/104/27/11150.full</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(5);

julia&gt; add_vertex!(g);

julia&gt; add_edge!(g, 5, 2);

julia&gt; k_crust(g, 0)
1-element Array{Int64,1}:
 6

julia&gt; k_crust(g, 1)
2-element Array{Int64,1}:
 1
 6

julia&gt; k_crust(g, 2)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/degeneracy.jl#L220-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.k_shell" href="#Graphs.k_shell"><code>Graphs.k_shell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">k_shell(g[, k]; corenum=core_number(g))</code></pre><p>Return a vector of vertices in the k-shell of <code>g</code>. If <code>k</code> is not specified, return the shell of the core with the largest degree.</p><p>The k-shell is the subgraph of vertices in the <code>k</code>-core but not in the (<code>k+1</code>)-core. This is similar to <code>k_corona</code> but in that case only neighbors in the k-core are considered.</p><p><strong>Implementation Notes</strong></p><p>Not implemented for graphs with parallel edges or self loops.</p><p><strong>References</strong></p><ul><li>A model of Internet topology using k-shell decomposition  Shai Carmi, Shlomo Havlin, Scott Kirkpatrick, Yuval Shavitt,  and Eran Shir, PNAS  July 3, 2007   vol. 104  no. 27  11150-11154  http://www.pnas.org/content/104/27/11150.full</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(5);

julia&gt; add_vertex!(g);

julia&gt; add_edge!(g, 5, 2);

julia&gt; k_shell(g, 0)
1-element Array{Int64,1}:
 6

julia&gt; k_shell(g, 1)
1-element Array{Int64,1}:
 1

julia&gt; k_shell(g, 2)
4-element Array{Int64,1}:
 2
 3
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/degeneracy.jl#L165-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.karger_cut_cost-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer" href="#Graphs.karger_cut_cost-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.karger_cut_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">karger_cut_cost(g, cut)</code></pre><p>Find the number of crossing edges in a cut of graph <code>g</code> where the cut is represented by the integer array, <code>cut</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/graphcut/karger_min_cut.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.karger_cut_edges-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer" href="#Graphs.karger_cut_edges-Union{Tuple{T}, Tuple{AbstractGraph{T}, Vector{&lt;:Integer}}} where T&lt;:Integer"><code>Graphs.karger_cut_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">karger_cut_edges(g, cut)</code></pre><p>Find the crossing edges in a cut of graph <code>g</code> where the cut is represented by the integer array, <code>cut</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/graphcut/karger_min_cut.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.karger_min_cut-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.karger_min_cut-Union{Tuple{AbstractGraph{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.karger_min_cut</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">karger_min_cut(g)</code></pre><p>Perform <a href="https://en.wikipedia.org/wiki/Karger%27s_algorithm">Karger Minimum Cut</a> to find the minimum cut of graph <code>g</code> with some probability of success. A cut is a partition of <code>vertices(g)</code> into two non-empty sets. The size of a cut is the number of edges crossing the two non-empty sets. </p><p><strong>Implementation Notes</strong></p><p>The cut is represented by an integer array. If <code>cut[v] == 1</code> then <code>v</code> is in the first non-empty set. If <code>cut[v] == 2</code> then <code>v</code> is in the second non-empty set. <code>cut[1] = 1</code>.</p><p>If |V| &lt; 2 then <code>cut[v] = 0</code> for all <code>v</code>.</p><p><strong>Performance</strong></p><p>Runtime: O(|E|) Memory: O(|E|)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/graphcut/karger_min_cut.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.karp_minimum_cycle_mean" href="#Graphs.karp_minimum_cycle_mean"><code>Graphs.karp_minimum_cycle_mean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">karp_minimum_cycle_mean(g[, distmx])</code></pre><p>Return minimum cycle mean of the directed graph <code>g</code> with optional edge weights contained in <code>distmx</code>.</p><p><strong>References</strong></p><ul><li><a href="http://dx.doi.org/10.1016/0012-365X(78)90011-0">Karp</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/karp.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.kruskal_mst" href="#Graphs.kruskal_mst"><code>Graphs.kruskal_mst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kruskal_mst(g, distmx=weights(g); minimize=true)</code></pre><p>Return a vector of edges representing the minimum (by default) spanning tree of a connected,  undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal&#39;s algorithm</a>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>minimize=true</code>: if set to <code>false</code>, calculate the maximum spanning tree.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/spanningtrees/kruskal.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.label_propagation-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T" href="#Graphs.label_propagation-Union{Tuple{AbstractGraph{T}}, Tuple{T}, Tuple{AbstractGraph{T}, Any}} where T"><code>Graphs.label_propagation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">label_propagation(g, maxiter=1000)</code></pre><p>Community detection using the label propagation algorithm. Return two vectors: the first is the label number assigned to each node, and the second is the convergence history for each node. Will return after <code>maxiter</code> iterations if convergence has not completed.</p><p><strong>References</strong></p><ul><li><a href="http://arxiv.org/abs/0709.2938">Raghavan et al.</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/label_propagation.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.loadgraph-Tuple{AbstractString, AbstractString, Graphs.AbstractGraphFormat}" href="#Graphs.loadgraph-Tuple{AbstractString, AbstractString, Graphs.AbstractGraphFormat}"><code>Graphs.loadgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadgraph(file, gname=&quot;graph&quot;, format=LGFormat())</code></pre><p>Read a graph named <code>gname</code> from <code>file</code> in the format <code>format</code>.</p><p><strong>Implementation Notes</strong></p><p><code>gname</code> is graph-format dependent and is only used if the file contains multiple graphs; if the file format does not support multiple graphs, this value is ignored. The default value may change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/persistence/common.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.loadgraphs-Tuple{AbstractString, Graphs.AbstractGraphFormat}" href="#Graphs.loadgraphs-Tuple{AbstractString, Graphs.AbstractGraphFormat}"><code>Graphs.loadgraphs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadgraphs(file, format=LGFormat())</code></pre><p>Load multiple graphs from <code>file</code> in the format <code>format</code>. Return a dictionary mapping graph name to graph.</p><p><strong>Implementation Notes</strong></p><p>For unnamed graphs the default name &quot;graph&quot; will be used. This default may change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/persistence/common.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.loadlg_mult-Tuple{IO}" href="#Graphs.loadlg_mult-Tuple{IO}"><code>Graphs.loadlg_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loadlg_mult(io)</code></pre><p>Return a dictionary of (name=&gt;graph) loaded from IO stream <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/persistence/lg.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.local_clustering-Tuple{AbstractGraph, Integer}" href="#Graphs.local_clustering-Tuple{AbstractGraph, Integer}"><code>Graphs.local_clustering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">local_clustering(g, v)
local_clustering(g, vs)</code></pre><p>Return a tuple <code>(a, b)</code>, where <code>a</code> is the number of triangles in the neighborhood of <code>v</code> and <code>b</code> is the maximum number of possible triangles. If a list of vertices <code>vs</code> is specified, return two vectors representing the number of triangles and the maximum number of possible triangles, respectively, for each node in the list.</p><p>This function is related to the local clustering coefficient <code>r</code> by <span>$r=\frac{a}{b}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/clustering.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.local_clustering_coefficient-Tuple{AbstractGraph, Integer}" href="#Graphs.local_clustering_coefficient-Tuple{AbstractGraph, Integer}"><code>Graphs.local_clustering_coefficient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">local_clustering_coefficient(g, v)
local_clustering_coefficient(g, vs)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Clustering_coefficient">local clustering coefficient</a> for node <code>v</code> in graph <code>g</code>. If a list of vertices <code>vs</code> is specified, return a vector of coefficients for each node in the list.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(4);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 4);

julia&gt; add_edge!(g, 4, 1);

julia&gt; local_clustering_coefficient(g, [1, 2, 3])
3-element Array{Float64,1}:
 1.0
 1.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/clustering.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.maximal_cliques" href="#Graphs.maximal_cliques"><code>Graphs.maximal_cliques</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximal_cliques(g)</code></pre><p>Return a vector of vectors representing the node indices in each of the maximal cliques found in the undirected graph <code>g</code>.</p><pre><code class="language-julia-repl">julia&gt; using Graphs
julia&gt; g = SimpleGraph(3)
julia&gt; add_edge!(g, 1, 2)
julia&gt; add_edge!(g, 2, 3)
julia&gt; maximal_cliques(g)
2-element Array{Array{Int64,N},1}:
 [2,3]
 [2,1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/cliques.jl#L8-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.maximum_adjacency_visit-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO, U}} where {U, T&lt;:Real}" href="#Graphs.maximum_adjacency_visit-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, AbstractMatrix{T}}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO}, Tuple{AbstractGraph{U}, AbstractMatrix{T}, Bool, IO, U}} where {U, T&lt;:Real}"><code>Graphs.maximum_adjacency_visit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">maximum_adjacency_visit(g[, distmx][, log][, io][, s])
maximum_adjacency_visit(g[, s])</code></pre><p>Return the vertices in <code>g</code> traversed by maximum adjacency search, optionally starting from vertex <code>s</code> (default <code>1</code>). An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/maxadjvisit.jl#L73-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.maxsimplecycles" href="#Graphs.maxsimplecycles"><code>Graphs.maxsimplecycles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maxsimplecycles(dg::::IsDirected, byscc::Bool = true)</code></pre><p>Compute the theoretical maximum number of cycles in the directed graph <code>dg</code>.</p><p>The computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (<code>byscc</code> parameter).</p><p><strong>Performance</strong></p><p>A more efficient version is possible.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L24-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.maxsimplecycles-Tuple{Integer}" href="#Graphs.maxsimplecycles-Tuple{Integer}"><code>Graphs.maxsimplecycles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">maxsimplecycles(n::Integer)</code></pre><p>Compute the theoretical maximum number of cycles in a directed graph of <code>n</code> vertices, assuming there are no self-loops.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L12-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.merge_vertices!-Union{Tuple{T}, Tuple{SimpleGraph{T}, Vector{U} where U&lt;:Integer}} where T" href="#Graphs.merge_vertices!-Union{Tuple{T}, Tuple{SimpleGraph{T}, Vector{U} where U&lt;:Integer}} where T"><code>Graphs.merge_vertices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_vertices!(g, vs)</code></pre><p>Combine vertices specified in <code>vs</code> into single vertex whose index will be the lowest value in <code>vs</code>. All edges connected to vertices in <code>vs</code> connect to the new merged vertex.</p><p>Return a vector with new vertex values are indexed by the original vertex indices.</p><p><strong>Implementation Notes</strong></p><p>Supports <a href="../generators/#Graphs.SimpleGraphs.SimpleGraph"><code>SimpleGraph</code></a> only.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(5);

julia&gt; collect(edges(g))
4-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4
 Edge 4 =&gt; 5

julia&gt; merge_vertices!(g, [2, 3])
5-element Array{Int64,1}:
 1
 2
 2
 3
 4

julia&gt; collect(edges(g))
3-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L770-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.merge_vertices-Tuple{Graphs.SimpleGraphs.AbstractSimpleGraph, Any}" href="#Graphs.merge_vertices-Tuple{Graphs.SimpleGraphs.AbstractSimpleGraph, Any}"><code>Graphs.merge_vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge_vertices(g::AbstractGraph, vs)</code></pre><p>Create a new graph where all vertices in <code>vs</code> have been aliased to the same vertex <code>minimum(vs)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(5);

julia&gt; collect(edges(g))
4-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4
 Edge 4 =&gt; 5

julia&gt; h = merge_vertices(g, [2, 3]);

julia&gt; collect(edges(h))
3-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 2 =&gt; 3
 Edge 3 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L719-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.mincut-Union{Tuple{AbstractGraph}, Tuple{T}, Tuple{AbstractGraph, AbstractMatrix{T}}} where T&lt;:Real" href="#Graphs.mincut-Union{Tuple{AbstractGraph}, Tuple{T}, Tuple{AbstractGraph, AbstractMatrix{T}}} where T&lt;:Real"><code>Graphs.mincut</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mincut(g, distmx=weights(g))</code></pre><p>Return a tuple <code>(parity, bestcut)</code>, where <code>parity</code> is a vector of integer values that determines the partition in <code>g</code> (1 or 2) and <code>bestcut</code> is the weight of the cut that makes this partition. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/maxadjvisit.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.modularity-Tuple{AbstractGraph, AbstractVector{&lt;:Integer}}" href="#Graphs.modularity-Tuple{AbstractGraph, AbstractVector{&lt;:Integer}}"><code>Graphs.modularity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">modularity(g, c, distmx=weights(g), γ=1.0)</code></pre><p>Return a value representing Newman&#39;s modularity <code>Q</code> for the undirected and  directed graph <code>g</code> given the partitioning vector <code>c</code>. This method also supports weighted graphs if the distance matrix is provided.</p><p>Modularity <span>$Q$</span> for undirected graph:</p><p class="math-container">\[Q = \frac{1}{2m} \sum_{c} \left( e_{c} - \gamma \frac{K_c^2}{2m} \right)\]</p><p>Modularity <span>$Q$</span> for directed graph:</p><p class="math-container">\[Q = \frac{1}{m} \sum_{c} \left( e_{c} - \gamma \frac{K_c^{in} K_c^{out}}{m} \right)\]</p><p>where:</p><ul><li><span>$m$</span>: total number of edges in the network </li><li><span>$e_c$</span>: number of edges in community <span>$c$</span></li><li><span>$K_c$</span>: sum of the degrees of the nodes in community <span>$c$</span> or the  sum of the weighted degree of the nodes in community <span>$c$</span> when the graph is  weighted. <span>$K_c^{in}$</span> sum of the in-degrees of the nodes in community <span>$c$</span>.</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>distmx=weights(g)</code>: distance matrix for weighted graphs</li><li><code>γ=1.0</code>: where <code>γ &gt; 0</code> is a resolution parameter. When the modularity is used  to find communities structure in networks (i.e with <a href="https://en.wikipedia.org/wiki/Louvain_Modularity">Louvain&#39;s method for  community detection</a>),  higher resolutions lead to more communities, while lower resolutions lead to  fewer communities. Where <code>γ=1.0</code> it lead to the traditional definition of  the modularity.</li></ul><p><strong>References</strong></p><ul><li>M. E. J. Newman and M. Girvan. &quot;Finding and evaluating community structure in networks&quot;.  Phys. Rev. E 69, 026113 (2004). <a href="https://arxiv.org/abs/cond-mat/0308217">(arXiv)</a></li><li>J. Reichardt and S. Bornholdt. &quot;Statistical mechanics of community detection&quot;.  Phys. Rev. E 74, 016110 (2006). <a href="https://arxiv.org/abs/cond-mat/0603718">(arXiv)</a></li><li>E. A. Leicht and M. E. J. Newman. &quot;Community structure in directed networks&quot;.  Physical Review Letter, 100:118703, (2008). <a href="https://arxiv.org/pdf/0709.4500.pdf">(arXiv)</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; barbell = blockdiag(complete_graph(3), complete_graph(3));

julia&gt; add_edge!(barbell, 1, 4);

julia&gt; modularity(barbell, [1, 1, 1, 2, 2, 2])
0.35714285714285715

julia&gt; modularity(barbell, [1, 1, 1, 2, 2, 2], γ=0.5)
0.6071428571428571  

julia&gt; using SimpleWeightedGraphs

julia&gt; triangle = SimpleWeightedGraph(3);

julia&gt; add_edge!(triangle, 1, 2, 1);

julia&gt; add_edge!(triangle, 2, 3, 1);

julia&gt; add_edge!(triangle, 3, 1, 1);

julia&gt; barbell = blockdiag(triangle, triangle);

julia&gt; add_edge!(barbell, 1, 4, 5); # this edge has a weight of 5

julia&gt; modularity(barbell, [1, 1, 1, 2, 2, 2])
0.045454545454545456</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/modularity.jl#L1-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.ncycles_n_i-Tuple{Integer, Integer}" href="#Graphs.ncycles_n_i-Tuple{Integer, Integer}"><code>Graphs.ncycles_n_i</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ncycles_n_i(n::Integer, i::Integer)</code></pre><p>Compute the theoretical maximum number of cycles of size <code>i</code> in a directed graph of <code>n</code>  vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.ne-Tuple{AbstractGraph}" href="#Graphs.ne-Tuple{AbstractGraph}"><code>Graphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ne(g)</code></pre><p>Return the number of edges in <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = path_graph(3);

julia&gt; ne(g)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighborhood-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}" href="#Graphs.neighborhood-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}"><code>Graphs.neighborhood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighborhood(g, v, d, distmx=weights(g))</code></pre><p>Return a vector of each vertex in <code>g</code> at a geodesic distance less than or equal to <code>d</code>, where distances may be specified by <code>distmx</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood(g, 1, 2)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; neighborhood(g, 1, 3)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; neighborhood(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Int64,1}:
 1
 2
 3
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L597-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighborhood_dists-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}" href="#Graphs.neighborhood_dists-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{T}, Integer, Any}, Tuple{AbstractGraph{T}, Integer, Any, AbstractMatrix{U}}} where {U&lt;:Real, T&lt;:Integer}"><code>Graphs.neighborhood_dists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighborhood_dists(g, v, d, distmx=weights(g))</code></pre><p>Return a a vector of tuples representing each vertex which is at a geodesic distance less than or equal to <code>d</code>, along with its distance from <code>v</code>. Non-negative distances may be specified by <code>distmx</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood_dists(g, 1, 3)
4-element Array{Tuple{Int64,Int64},1}:
 (1, 0)
 (2, 1)
 (3, 2)
 (4, 3)

julia&gt; neighborhood_dists(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Tuple{Int64,Float64},1}:
 (1, 0.0)
 (2, 1.0)
 (3, 2.0)
 (4, 2.25)
 (5, 2.5)

julia&gt; neighborhood_dists(g, 4, 3)
2-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (5, 1)

julia&gt; neighborhood_dists(g, 4, 3, dir=:in)
5-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (3, 1)
 (5, 1)
 (2, 2)
 (1, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L636-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighbors-Tuple{AbstractGraph, Integer}" href="#Graphs.neighbors-Tuple{AbstractGraph, Integer}"><code>Graphs.neighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neighbors(g, v)</code></pre><p>Return a list of all neighbors reachable from vertex <code>v</code> in <code>g</code>. For directed graphs, the default is equivalent to <a href="#Graphs.outneighbors-Tuple{Any, Any}"><code>outneighbors</code></a>; use <a href="#Graphs.all_neighbors"><code>all_neighbors</code></a> to list inbound and outbound neighbors.</p><p><strong>Implementation Notes</strong></p><p>Returns a reference to the current graph&#39;s internal structures, not a copy.  Do not modify result. If the graph is modified, the behavior is undefined:  the array behind this reference may be modified too, but this is not guaranteed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = DiGraph(3);

julia&gt; add_edge!(g, 2, 3);

julia&gt; add_edge!(g, 3, 1);

julia&gt; neighbors(g, 1)
0-element Array{Int64,1}

julia&gt; neighbors(g, 2)
1-element Array{Int64,1}:
 3

julia&gt; neighbors(g, 3)
1-element Array{Int64,1}:
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L208-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.noallocextreme-NTuple{4, Any}" href="#Graphs.noallocextreme-NTuple{4, Any}"><code>Graphs.noallocextreme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">noallocextreme(f, comparison, initial, g)</code></pre><p>Compute the extreme value of <code>[f(g,i) for i=i:nv(g)]</code> without gathering them all</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.non_backtracking_randomwalk" href="#Graphs.non_backtracking_randomwalk"><code>Graphs.non_backtracking_randomwalk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">non_backtracking_randomwalk(g, s, niter; seed=-1)</code></pre><p>Perform a non-backtracking random walk on directed graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/randomwalks.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.normalized_cut-Union{Tuple{T}, Tuple{AbstractGraph, Real}, Tuple{AbstractGraph, Real, AbstractMatrix{T}}, Tuple{AbstractGraph, Real, AbstractMatrix{T}, Int64}} where T&lt;:Real" href="#Graphs.normalized_cut-Union{Tuple{T}, Tuple{AbstractGraph, Real}, Tuple{AbstractGraph, Real, AbstractMatrix{T}}, Tuple{AbstractGraph, Real, AbstractMatrix{T}, Int64}} where T&lt;:Real"><code>Graphs.normalized_cut</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalized_cut(g, thres, distmx=weights(g), [num_cuts=10]);</code></pre><p>Perform <a href="https://en.wikipedia.org/wiki/Segmentation-based_object_categorization#Normalized_cuts">recursive two-way normalized graph-cut</a> on a graph, partitioning the vertices into disjoint sets. Return a vector that contains the set index for each vertex.</p><p>It is important to identify a good threshold for your application. A bisection search over the range (0,1) will help determine a good value of thres.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>thres</code>: Subgraphs aren&#39;t split if best normalized cut is above this threshold</li><li><code>num_cuts</code>: Number of cuts performed to determine optimal cut</li></ul><p><strong>References</strong></p><p>&quot;Normalized Cuts and Image Segmentation&quot; - Jianbo Shi and Jitendra Malik</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/graphcut/normalized_cut.jl#L168-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.num_self_loops-Tuple{AbstractGraph}" href="#Graphs.num_self_loops-Tuple{AbstractGraph}"><code>Graphs.num_self_loops</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_self_loops(g)</code></pre><p>Return the number of self loops in <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; num_self_loops(g)
0

julia&gt; add_edge!(g, 1, 1);

julia&gt; num_self_loops(g)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L350-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.nv-Tuple{AbstractGraph}" href="#Graphs.nv-Tuple{AbstractGraph}"><code>Graphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nv(g)</code></pre><p>Return the number of vertices in <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; nv(SimpleGraph(3))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L128-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.optimal_contiguous_partition-Union{Tuple{U}, Tuple{Vector{&lt;:Integer}, Integer}, Tuple{Vector{&lt;:Integer}, Integer, U}} where U&lt;:Integer" href="#Graphs.optimal_contiguous_partition-Union{Tuple{U}, Tuple{Vector{&lt;:Integer}, Integer}, Tuple{Vector{&lt;:Integer}, Integer, U}} where U&lt;:Integer"><code>Graphs.optimal_contiguous_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">optimal_contiguous_partition(weight, required_partitions, num_items=length(weight))</code></pre><p>Partition <code>1:num_items</code> into atmost <code>required_partitions</code> number of contiguous partitions such that the largest partition is minimised. The size of a partition is equal to the sum of the weight of its elements. <code>weight[i] &gt; 0</code>.</p><p><strong>Performance</strong></p><p>Time: O(num_items*log(sum(weight)))</p><p><strong>Implementation Notes</strong></p><p>Binary Search for the partitioning over <code>[fld(sum(weight)-1, required_partitions), sum(weight)]</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L161-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outdegree-Tuple{AbstractGraph, Integer}" href="#Graphs.outdegree-Tuple{AbstractGraph, Integer}"><code>Graphs.outdegree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">outdegree(g[, v])</code></pre><p>Return a vector corresponding to the number of edges which start at each vertex in graph <code>g</code>. If <code>v</code> is specified, only return degrees for vertices in <code>v</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = DiGraph(3);

julia&gt; add_edge!(g, 2, 3);

julia&gt; add_edge!(g, 3, 1);

julia&gt; outdegree(g)
3-element Array{Int64,1}:
 0
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L73-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.outneighbors-Tuple{Any, Any}" href="#Graphs.outneighbors-Tuple{Any, Any}"><code>Graphs.outneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">outneighbors(g, v)</code></pre><p>Return a list of all neighbors connected to vertex <code>v</code> by an outgoing edge.</p><p><strong>Implementation Notes</strong></p><p>Returns a reference to the current graph&#39;s internal structures, not a copy. Do not modify result. If the graph is modified, the behavior is undefined: the array behind this reference may be modified too, but this is not guaranteed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; outneighbors(g, 4)
1-element Array{Int64,1}:
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L301-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.period" href="#Graphs.period"><code>Graphs.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">period(g)</code></pre><p>Return the (common) period for all vertices in a strongly connected directed graph. Will throw an error if the graph is not strongly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; period(g)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L479-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.periphery-Tuple{Vector}" href="#Graphs.periphery-Tuple{Vector}"><code>Graphs.periphery</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">periphery(eccentricities)
periphery(g, distmx=weights(g))</code></pre><p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the set of all vertices whose eccentricity is equal to the graph&#39;s diameter (that is, the set of vertices with the largest eccentricity).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; periphery(star_graph(5))
4-element Array{Int64,1}:
 2
 3
 4
 5

julia&gt; periphery(path_graph(5))
2-element Array{Int64,1}:
 1
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/distance.jl#L109-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.prim_mst" href="#Graphs.prim_mst"><code>Graphs.prim_mst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prim_mst(g, distmx=weights(g))</code></pre><p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim&#39;s algorithm</a>. Return a vector of edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/spanningtrees/prim.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.radius-Tuple{Vector}" href="#Graphs.radius-Tuple{Vector}"><code>Graphs.radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">radius(eccentricities)
radius(g, distmx=weights(g))</code></pre><p>Given a graph and optional distance matrix, or a vector of precomputed eccentricities, return the minimum eccentricity of the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; radius(star_graph(5))
1

julia&gt; radius(path_graph(5))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/distance.jl#L143-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.randomwalk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}" href="#Graphs.randomwalk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.randomwalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomwalk(g, s, niter; seed=-1)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/randomwalks.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.range_shuffle!-Tuple{UnitRange, AbstractVector}" href="#Graphs.range_shuffle!-Tuple{UnitRange, AbstractVector}"><code>Graphs.range_shuffle!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">range_shuffle!(r, a; seed=-1)</code></pre><p>Fast shuffle Array <code>a</code> in UnitRange <code>r</code>. Uses <code>seed</code> to initialize the random number generator, defaulting to <code>Random.GLOBAL_RNG</code> for <code>seed=-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/label_propagation.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.resetB!-Tuple{Any}" href="#Graphs.resetB!-Tuple{Any}"><code>Graphs.resetB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resetB!(B)</code></pre><p>Reset B work structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/hawick-james.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.resetblocked!-Tuple{Any}" href="#Graphs.resetblocked!-Tuple{Any}"><code>Graphs.resetblocked!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resetblocked!(blocked)</code></pre><p>Reset vector of <code>blocked</code> vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/hawick-james.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.rich_club-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}} where T" href="#Graphs.rich_club-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}} where T"><code>Graphs.rich_club</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rich_club(g, k)</code></pre><p>Return the non-normalised <a href="https://en.wikipedia.org/wiki/Rich-club_coefficient">rich-club coefficient</a> of graph <code>g</code>, with degree cut-off <code>k</code>.</p><pre><code class="language-julia-repl">julia&gt; using LightGraphs
julia&gt; g = star_graph(5)
julia&gt; rich_club(g, 1)
0.4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/rich_club.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.sample!-Tuple{Random.AbstractRNG, AbstractVector, Integer}" href="#Graphs.sample!-Tuple{Random.AbstractRNG, AbstractVector, Integer}"><code>Graphs.sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample!([rng, ]a, k)</code></pre><p>Sample <code>k</code> element from array <code>a</code> without repetition and eventually excluding elements in <code>exclude</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>exclude=()</code>: elements in <code>a</code> to exclude from sampling.</li></ul><p><strong>Implementation Notes</strong></p><p>Changes the order of the elements in <code>a</code>. For a non-mutating version, see <a href="#Graphs.sample-Tuple{AbstractVector, Integer}"><code>sample</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.sample-Tuple{AbstractVector, Integer}" href="#Graphs.sample-Tuple{AbstractVector, Integer}"><code>Graphs.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample([rng,] r, k)</code></pre><p>Sample <code>k</code> element from unit range <code>r</code> without repetition and eventually excluding elements in <code>exclude</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>exclude=()</code>: elements in <code>a</code> to exclude from sampling.</li></ul><p><strong>Implementation Notes</strong></p><p>Unlike <a href="#Graphs.sample!-Tuple{Random.AbstractRNG, AbstractVector, Integer}"><code>sample!</code></a>, does not produce side effects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.savegraph-Tuple{AbstractString, AbstractGraph, AbstractString, Graphs.AbstractGraphFormat}" href="#Graphs.savegraph-Tuple{AbstractString, AbstractGraph, AbstractString, Graphs.AbstractGraphFormat}"><code>Graphs.savegraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savegraph(file, g, gname=&quot;graph&quot;, format=LGFormat)</code></pre><p>Saves a graph <code>g</code> with name <code>gname</code> to <code>file</code> in the format <code>format</code>. Return the number of graphs written.</p><p><strong>Implementation Notes</strong></p><p>The default graph name assigned to <code>gname</code> may change in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/persistence/common.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.savegraph-Union{Tuple{T}, Tuple{U}, Tuple{AbstractString, Dict{T, U}, Graphs.AbstractGraphFormat}} where {U&lt;:AbstractGraph, T&lt;:AbstractString}" href="#Graphs.savegraph-Union{Tuple{T}, Tuple{U}, Tuple{AbstractString, Dict{T, U}, Graphs.AbstractGraphFormat}} where {U&lt;:AbstractGraph, T&lt;:AbstractString}"><code>Graphs.savegraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savegraph(file, g, d, format=LGFormat)</code></pre><p>Save a dictionary of <code>graphname =&gt; graph</code> to <code>file</code> in the format <code>format</code>. Return the number of graphs written.</p><p><strong>Implementation Notes</strong></p><p>Will only work if the file format supports multiple graph types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/persistence/common.jl#L97-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.savelg-Union{Tuple{T}, Tuple{IO, AbstractGraph{T}, String}} where T" href="#Graphs.savelg-Union{Tuple{T}, Tuple{IO, AbstractGraph{T}, String}} where T"><code>Graphs.savelg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savelg(io, g, gname)</code></pre><p>Write a graph <code>g</code> with name <code>gname</code> in a proprietary format to the IO stream designated by <code>io</code>. Return 1 (number of graphs written).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/persistence/lg.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.savelg_mult-Tuple{IO, Dict}" href="#Graphs.savelg_mult-Tuple{IO, Dict}"><code>Graphs.savelg_mult</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savelg_mult(io, graphs)</code></pre><p>Write a dictionary of (name=&gt;graph) to an IO stream <code>io</code>, with default <code>GZip</code> compression. Return number of graphs written.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/persistence/lg.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.self_avoiding_walk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}" href="#Graphs.self_avoiding_walk-Union{Tuple{AG}, Tuple{T}, Tuple{AG, Integer, Integer}} where {T, AG&lt;:AbstractGraph{T}}"><code>Graphs.self_avoiding_walk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">self_avoiding_walk(g, s, niter; seed=-1)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/randomwalks.jl#L95-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.simplecycles" href="#Graphs.simplecycles"><code>Graphs.simplecycles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplecycles(dg::::IsDirected)</code></pre><p>Compute and return all cycles of the given directed graph using Johnson&#39;s algorithm.</p><p><strong>Performance</strong></p><p>The number of cycles grows more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – <a href="#Graphs.simplecycles_iter"><code>simplecycles_iter</code></a> – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code>. If you only need short cycles of a limited length, <a href="../pathing/#Graphs.simplecycles_limited_length"><code>simplecycles_limited_length</code></a> can be more efficient.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; simplecycles(complete_digraph(3))
5-element Array{Array{Int64,1},1}:
 [1, 2]
 [1, 2, 3]
 [1, 3]
 [1, 3, 2]
 [2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L160-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.simplecycles_hawick_james" href="#Graphs.simplecycles_hawick_james"><code>Graphs.simplecycles_hawick_james</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplecycles_hawick_james(g)</code></pre><p>Find circuits (including self-loops) in <code>g</code> using the algorithm of Hawick &amp; James.</p><p><strong>References</strong></p><ul><li>Hawick &amp; James, &quot;Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs&quot;, 2008</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/hawick-james.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.simplecycles_iter" href="#Graphs.simplecycles_iter"><code>Graphs.simplecycles_iter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplecycles_iter(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm, up to the ceiling (to avoid memory overload).</p><p><strong>Implementation Notes</strong></p><p>If the graph is small, the ceiling will not be reached and <code>simplecycles(dg::DiGraph)</code> is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the <code>ceiling</code> is not reached, a subset of them otherwise.</p><p>To get an idea of the possible number of cycles, use function `maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L317-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T" href="#Graphs.simplecycles_limited_length-Union{Tuple{T}, Tuple{AbstractGraph{T}, Int64}, Tuple{AbstractGraph{T}, Int64, Any}} where T"><code>Graphs.simplecycles_limited_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simplecycles_limited_length(g, n, ceiling=10^6)</code></pre><p>Compute and return at most <code>ceiling</code> cycles of length at most <code>n</code> of the given graph. Both directed and undirected graphs are supported.</p><p><strong>Performance</strong></p><p>The number of cycles grows very fast with the number of vertices and the allowed length of the cycles. This function is intended for finding short cycles. If you want to find cycles of any length in a directed graph, <a href="../community/#Graphs.simplecycles"><code>simplecycles</code></a> or <a href="../community/#Graphs.simplecycles_iter"><code>simplecycles_iter</code></a> may be more efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/limited_length.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.simplecyclescount" href="#Graphs.simplecyclescount"><code>Graphs.simplecyclescount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplecyclescount(dg::DiGraph, ceiling = 10^6)</code></pre><p>Count the number of cycles in a directed graph, using Johnson&#39;s algorithm. Return the minimum of the ceiling and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>The <code>ceiling</code> is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> to get an idea of the theoretical maximum number or cycles.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; simplecyclescount(complete_digraph(6))
409</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L287-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.simplecycleslength" href="#Graphs.simplecycleslength"><code>Graphs.simplecycleslength</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplecycleslength(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm, and return a tuple representing the cycle length and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p><p>If the <code>ceiling</code> is reached (<code>ncycles = ceiling</code>), the output is only a subset of the cycles lengths.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; simplecycleslength(complete_digraph(16))
([0, 1, 1, 1, 1, 1, 2, 10, 73, 511, 3066, 15329, 61313, 183939, 367876, 367876], 1000000)

julia&gt; simplecycleslength(wheel_digraph(16))
([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L339-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.spfa_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, Integer}, Tuple{AbstractGraph{U}, Integer, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}" href="#Graphs.spfa_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph{U}, Integer}, Tuple{AbstractGraph{U}, Integer, AbstractMatrix{T}}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.spfa_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spfa_shortest_paths(g, s, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> and all other nodes in graph <code>g</code> using the <a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm">Shortest Path Faster Algorithm</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = complete_graph(3);

julia&gt; d = [1 -3 1; -3 1 1; 1 1 1];

julia&gt; spfa_shortest_paths(g, 1, d)

ERROR: Graphs.NegativeCycleError()

julia&gt; g = complete_graph(4);

julia&gt; d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];

julia&gt; spfa_shortest_paths(gx, 1, d)

4-element Array{Int64,1}:
  0
  0
 -1
  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/spfa.jl#L12-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.squash-Tuple{AbstractGraph}" href="#Graphs.squash-Tuple{AbstractGraph}"><code>Graphs.squash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">squash(g)</code></pre><p>Return a copy of a graph with the smallest practical type that can accommodate all vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L389-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.src-Tuple{AbstractEdge}" href="#Graphs.src-Tuple{AbstractEdge}"><code>Graphs.src</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">src(e)</code></pre><p>Return the source vertex of edge <code>e</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; src(first(edges(g)))
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L48-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.steiner_tree" href="#Graphs.steiner_tree"><code>Graphs.steiner_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">steiner_tree(g, term_vert, distmx=weights(g))</code></pre><p>Return an approximately minimum steiner tree of connected, undirected graph <code>g</code> with positive edge  weights represented by <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Steiner_tree_problem#Approximating_the_Steiner_tree">Approximate Steiner Tree</a>.  The minimum steiner tree problem involves finding a subset of edges in <code>g</code> of minimum weight such that all the vertices in <code>term_vert</code> are connected.</p><p><code>t = length(term_vert)</code>.</p><p><strong>Performance</strong></p><p>Runtime: O(t<em>(t</em>log(t)+|E|<em>log(|V| )) Memory: O(t</em>|V|) Approximation Factor: 2-2/t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/steinertree/steiner_tree.jl#L28-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.strongly_connected_components" href="#Graphs.strongly_connected_components"><code>Graphs.strongly_connected_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">strongly_connected_components(g)</code></pre><p>Compute the strongly connected components of a directed graph <code>g</code>.</p><p>Return an array of arrays, each of which is the entire connected component.</p><p><strong>Implementation Notes</strong></p><p>The order of the components is not part of the API contract.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; strongly_connected_components(g)
2-element Array{Array{Int64,1},1}:
 [3]
 [1, 2]


julia&gt; g=SimpleDiGraph(11)
{11, 0} directed simple Int64 graph

julia&gt; edge_list=[(1,2),(2,3),(3,4),(4,1),(3,5),(5,6),(6,7),(7,5),(5,8),(8,9),(9,8),(10,11),(11,10)];

julia&gt; g = SimpleDiGraph(Edge.(edge_list))
{11, 13} directed simple Int64 graph

julia&gt; strongly_connected_components(g)
4-element Array{Array{Int64,1},1}:
 [8, 9]      
 [5, 6, 7]   
 [1, 2, 3, 4]
 [10, 11]    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L180-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.strongly_connected_components_kosaraju" href="#Graphs.strongly_connected_components_kosaraju"><code>Graphs.strongly_connected_components_kosaraju</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">strongly_connected_components_kosaraju(g)</code></pre><p>Compute the strongly connected components of a directed graph <code>g</code> using Kosaraju&#39;s Algorithm.  (https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm).</p><p>Return an array of arrays, each of which is the entire connected component.</p><p><strong>Performance</strong></p><p>Time Complexity : O(|E|+|V|) Space Complexity : O(|V|) {Excluding the memory required for storing graph}</p><p>|V| = Number of vertices |E| = Number of edges</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; g=SimpleDiGraph(3)
{3, 0} directed simple Int64 graph

julia&gt; g = SimpleDiGraph([0 1 0 ; 0 0 1; 0 0 0])
{3, 2} directed simple Int64 graph

julia&gt; strongly_connected_components_kosaraju(g)
3-element Array{Array{Int64,1},1}:
 [1]
 [2]
 [3]


julia&gt; g=SimpleDiGraph(11)
{11, 0} directed simple Int64 graph

julia&gt; edge_list=[(1,2),(2,3),(3,4),(4,1),(3,5),(5,6),(6,7),(7,5),(5,8),(8,9),(9,8),(10,11),(11,10)]
13-element Array{Tuple{Int64,Int64},1}:
 (1, 2)  
 (2, 3)  
 (3, 4)  
 (4, 1)  
 (3, 5)  
 (5, 6)  
 (6, 7)  
 (7, 5)  
 (5, 8)  
 (8, 9)  
 (9, 8)  
 (10, 11)
 (11, 10)

julia&gt; g = SimpleDiGraph(Edge.(edge_list))
{11, 13} directed simple Int64 graph

julia&gt; strongly_connected_components_kosaraju(g)
4-element Array{Array{Int64,1},1}:
 [11, 10]    
 [2, 3, 4, 1]
 [6, 7, 5]   
 [9, 8]      
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L312-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.symmetric_difference-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph" href="#Graphs.symmetric_difference-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>Graphs.symmetric_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetric_difference(g, h)</code></pre><p>Return a graph with edges from graph <code>g</code> that do not exist in graph <code>h</code>, and vice versa.</p><p><strong>Implementation Notes</strong></p><p>Note that this function may produce a graph with 0-degree vertices. Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3); h = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(h, 1, 3);

julia&gt; add_edge!(h, 2, 3);

julia&gt; f = symmetric_difference(g, h);

julia&gt; collect(edges(f))
3-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 2 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L207-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.tensor_product-Union{Tuple{G}, Tuple{G, G}} where G&lt;:AbstractGraph" href="#Graphs.tensor_product-Union{Tuple{G}, Tuple{G, G}} where G&lt;:AbstractGraph"><code>Graphs.tensor_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tensor_product(g, h)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Tensor_product_of_graphs">tensor product</a> of <code>g</code> and <code>h</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the eltype.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = tensor_product(star_graph(3), path_graph(3))
{9, 8} undirected simple Int64 graph

julia&gt; collect(edges(g))
8-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 5
 Edge 1 =&gt; 8
 Edge 2 =&gt; 4
 Edge 2 =&gt; 6
 Edge 2 =&gt; 7
 Edge 2 =&gt; 9
 Edge 3 =&gt; 5
 Edge 3 =&gt; 8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L553-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.topological_sort_by_dfs" href="#Graphs.topological_sort_by_dfs"><code>Graphs.topological_sort_by_dfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">topological_sort_by_dfs(g)</code></pre><p>Return a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> of a directed graph <code>g</code> as a vector of vertices in topological order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/dfs.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.transitiveclosure" href="#Graphs.transitiveclosure"><code>Graphs.transitiveclosure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transitiveclosure(g, selflooped=false)</code></pre><p>Compute the transitive closure of a directed graph, using DFS. Return a graph representing the transitive closure. If <code>selflooped</code> is <code>true</code>, add self loops to the graph.</p><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(|E||V|)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; barbell = blockdiag(complete_digraph(3), complete_digraph(3));

julia&gt; add_edge!(barbell, 1, 4);

julia&gt; collect(edges(barbell))
13-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 1 =&gt; 4
 Edge 2 =&gt; 1
 Edge 2 =&gt; 3
 Edge 3 =&gt; 1
 Edge 3 =&gt; 2
 Edge 4 =&gt; 5
 Edge 4 =&gt; 6
 Edge 5 =&gt; 4
 Edge 5 =&gt; 6
 Edge 6 =&gt; 4
 Edge 6 =&gt; 5

julia&gt; collect(edges(transitiveclosure(barbell)))
21-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 1 =&gt; 4
 Edge 1 =&gt; 5
 Edge 1 =&gt; 6
 Edge 2 =&gt; 1
 Edge 2 =&gt; 3
 Edge 2 =&gt; 4
 Edge 2 =&gt; 5
 Edge 2 =&gt; 6
 Edge 3 =&gt; 1
 Edge 3 =&gt; 2
 Edge 3 =&gt; 4
 Edge 3 =&gt; 5
 Edge 3 =&gt; 6
 Edge 4 =&gt; 5
 Edge 4 =&gt; 6
 Edge 5 =&gt; 4
 Edge 5 =&gt; 6
 Edge 6 =&gt; 4
 Edge 6 =&gt; 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/digraph/transitivity.jl#L46-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.transitiveclosure!" href="#Graphs.transitiveclosure!"><code>Graphs.transitiveclosure!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transitiveclosure!(g, selflooped=false)</code></pre><p>Compute the transitive closure of a directed graph, using DFS. If <code>selflooped</code> is true, add self loops to the graph.</p><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(|E||V|)$</span>.</p><p><strong>Implementation Notes</strong></p><p>This version of the function modifies the original graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/digraph/transitivity.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.transitivereducion" href="#Graphs.transitivereducion"><code>Graphs.transitivereducion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transitivereduction(g; selflooped=false)</code></pre><p>Compute the transitive reduction of  a directed graph. If the graph contains cycles, each strongly connected component is replaced by a directed cycle and the transitive reduction is calculated on the condensation graph connecting the components. If <code>selflooped</code> is true, self loops on strongly connected components of size one will be preserved.</p><p><strong>Performance</strong></p><p>Time complexity is <span>$\mathcal{O}(|V||E|)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; barbell = blockdiag(complete_digraph(3), complete_digraph(3));

julia&gt; add_edge!(barbell, 1, 4);

julia&gt; collect(edges(barbell))
13-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 3
 Edge 1 =&gt; 4
 Edge 2 =&gt; 1
 Edge 2 =&gt; 3
 Edge 3 =&gt; 1
 Edge 3 =&gt; 2
 Edge 4 =&gt; 5
 Edge 4 =&gt; 6
 Edge 5 =&gt; 4
 Edge 5 =&gt; 6
 Edge 6 =&gt; 4
 Edge 6 =&gt; 5

julia&gt; collect(edges(transitivereduction(barbell)))
7-element Array{Graphs.SimpleGraphs.SimpleEdge{Int64},1}:
 Edge 1 =&gt; 2
 Edge 1 =&gt; 4
 Edge 2 =&gt; 3
 Edge 3 =&gt; 1
 Edge 4 =&gt; 5
 Edge 5 =&gt; 6
 Edge 6 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/digraph/transitivity.jl#L110-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer" href="#Graphs.tree-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Integer"><code>Graphs.tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tree(parents)</code></pre><p>Convert a parents array into a directed graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/traversals/bfs.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.triangles-Tuple{AbstractGraph, Integer}" href="#Graphs.triangles-Tuple{AbstractGraph, Integer}"><code>Graphs.triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangles(g[, v])
triangles(g, vs)</code></pre><p>Return the number of triangles in the neighborhood of node <code>v</code> in graph <code>g</code>. If a list of vertices <code>vs</code> is specified, return a vector of number of triangles for each node in the list. If no vertices are specified, return the number of triangles for each node in the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(4);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 4);

julia&gt; add_edge!(g, 4, 1);

julia&gt; triangles(g)
4-element Array{Int64,1}:
 1
 1
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/clustering.jl#L93-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.unblock!-Union{Tuple{T}, Tuple{T, AbstractVector, Array{Vector{T}, 1}}} where T" href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, AbstractVector, Array{Vector{T}, 1}}} where T"><code>Graphs.unblock!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unblock!(v, blocked, B)</code></pre><p>Unblock the value <code>v</code> from the <code>blocked</code> list and remove from <code>B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/hawick-james.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.unblock!-Union{Tuple{T}, Tuple{T, BitVector, Array{Set{T}, 1}}} where T&lt;:Integer" href="#Graphs.unblock!-Union{Tuple{T}, Tuple{T, BitVector, Array{Set{T}, 1}}} where T&lt;:Integer"><code>Graphs.unblock!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unblock!{T&lt;:Integer}(v::T, blocked::BitVector, B::Vector{Set{T}})</code></pre><p>Unblock the vertices recursively.</p><p><code>v</code> is the vertex to unblock, <code>blocked</code> tells whether a vertex is blocked or not and <code>B</code> is the map that tells if the unblocking of one vertex should unblock other vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/cycles/johnson.jl#L87-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.unweighted_contiguous_partition-Tuple{Integer, Integer}" href="#Graphs.unweighted_contiguous_partition-Tuple{Integer, Integer}"><code>Graphs.unweighted_contiguous_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unweighted_contiguous_partition(num_items, required_partitions)</code></pre><p>Partition <code>1:num_items</code> into <code>required_partitions</code> number of partitions such that the difference in length of the largest and smallest partition is atmost 1.</p><p><strong>Performance</strong></p><p>Time: O(required_partitions)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/utils.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.update_dominated!-Union{Tuple{T}, Tuple{AbstractGraph{T}, DataStructures.PriorityQueue, Integer, BitVector, BitVector}} where T&lt;:Integer" href="#Graphs.update_dominated!-Union{Tuple{T}, Tuple{AbstractGraph{T}, DataStructures.PriorityQueue, Integer, BitVector, BitVector}} where T&lt;:Integer"><code>Graphs.update_dominated!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_dominated!(degree_queue, v, dominated, in_dom_set)</code></pre><p>Check if a vertex is already dominated. If not, make it dominated and update <code>degree_queue</code> by decreasing the priority of the vertices adjacent to <code>v</code> by 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/dominatingset/degree_dom_set.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeVertexCover}} where T&lt;:Integer" href="#Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, DegreeVertexCover}} where T&lt;:Integer"><code>Graphs.vertex_cover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertex_cover(g, DegreeVertexCover())</code></pre><p>Obtain a vertex cover using a greedy heuristic.</p><p><strong>Implementation Notes</strong></p><p>An edge is said to be covered if it has at least one end-point in the vertex cover. Initialise the vertex cover to an empty set and iteratively choose the vertex with the most uncovered edges.</p><p><strong>Performance</strong></p><p>Runtime: O((|V|+|E|)*log(|V|)) Memory: O(|V|)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; vertex_cover(path_graph(3), DegreeVertexCover())
1-element Array{Int64,1}:
 2

julia&gt; vertex_cover(cycle_graph(3), DegreeVertexCover())
2-element Array{Int64,1}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/vertexcover/degree_vertex_cover.jl#L5-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, RandomVertexCover}} where T&lt;:Integer" href="#Graphs.vertex_cover-Union{Tuple{T}, Tuple{AbstractGraph{T}, RandomVertexCover}} where T&lt;:Integer"><code>Graphs.vertex_cover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertex_cover(g, RandomVertexCover(); seed=-1)</code></pre><p>Find a set of vertices such that every edge in <code>g</code> has some vertex in the set as  atleast one of its end point.</p><p><strong>Implementation Notes</strong></p><p>Performs <a href="https://en.wikipedia.org/wiki/Vertex_cover#Approximate_evaluation">Approximate Minimum Vertex Cover</a> once. Returns a vector of vertices representing the vertices in the Vertex Cover.</p><p><strong>Performance</strong></p><p>Runtime: O(|V|+|E|) Memory: O(|E|) Approximation Factor: 2</p><p><strong>Optional Arguments</strong></p><ul><li>If <code>seed &gt;= 0</code>, a random generator is seeded with this value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/vertexcover/random_vertex_cover.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vertices-Tuple{AbstractGraph}" href="#Graphs.vertices-Tuple{AbstractGraph}"><code>Graphs.vertices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertices(g)</code></pre><p>Return (an iterator to or collection of) the vertices of a graph.</p><p><strong>Implementation Notes</strong></p><p>A returned iterator is valid for one pass over the edges, and is invalidated by changes to <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; collect(vertices(SimpleGraph(4)))
4-element Array{Int64,1}:
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/interface.jl#L160-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.visit!-Union{Tuple{E}, Tuple{AbstractGraph, Graphs.Biconnections{E}, Integer, Integer}} where E" href="#Graphs.visit!-Union{Tuple{E}, Tuple{AbstractGraph, Graphs.Biconnections{E}, Integer, Integer}} where E"><code>Graphs.visit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">visit!(g, state, u, v)</code></pre><p>Perform a DFS visit storing the depth and low-points of each vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/biconnectivity/biconnect.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.vote!-Tuple{AbstractGraph, Vector, Graphs.NeighComm, Integer}" href="#Graphs.vote!-Tuple{AbstractGraph, Vector, Graphs.NeighComm, Integer}"><code>Graphs.vote!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vote!(g, m, c, u)</code></pre><p>Return the label with greatest frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/community/label_propagation.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.weakly_connected_components-Tuple{Any}" href="#Graphs.weakly_connected_components-Tuple{Any}"><code>Graphs.weakly_connected_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">weakly_connected_components(g)</code></pre><p>Return the weakly connected components of the graph <code>g</code>. This is equivalent to the connected components of the undirected equivalent of <code>g</code>. For undirected graphs this is equivalent to the <a href="#Graphs.connected_components"><code>connected_components</code></a> of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; weakly_connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/connectivity.jl#L134-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.weights-Tuple{AbstractGraph}" href="#Graphs.weights-Tuple{AbstractGraph}"><code>Graphs.weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">weights(g)</code></pre><p>Return the weights of the edges of a graph <code>g</code> as a matrix. Defaults to <a href="#Graphs.DefaultDistance"><code>Graphs.DefaultDistance</code></a>.</p><p><strong>Implementation Notes</strong></p><p>In general, referencing the weight of a nonexistent edge is undefined behavior. Do not rely on the <code>weights</code> matrix as a substitute for the graph&#39;s <a href="../linalg/#Graphs.LinAlg.adjacency_matrix"><code>adjacency_matrix</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L404-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.yen_k_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, U, U}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}, Int64}} where {U&lt;:Integer, T&lt;:Real}" href="#Graphs.yen_k_shortest_paths-Union{Tuple{T}, Tuple{U}, Tuple{AbstractGraph, U, U}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}}, Tuple{AbstractGraph, U, U, AbstractMatrix{T}, Int64}} where {U&lt;:Integer, T&lt;:Real}"><code>Graphs.yen_k_shortest_paths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Yen%27s_algorithm">Yen&#39;s algorithm</a> on a graph, computing k-shortest distances between <code>source</code> and <code>target</code> other vertices. Return a <a href="../community/#Graphs.YenState"><code>YenState</code></a> that contains distances and paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/shortestpaths/yen.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Δ-Tuple{Any}" href="#Graphs.Δ-Tuple{Any}"><code>Graphs.Δ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Δ(g)</code></pre><p>Return the maximum <a href="#Graphs.degree"><code>degree</code></a> of vertices in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Δin-Tuple{Any}" href="#Graphs.Δin-Tuple{Any}"><code>Graphs.Δin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Δin(g)</code></pre><p>Return the maximum <a href="#Graphs.indegree-Tuple{AbstractGraph, Integer}"><code>indegree</code></a> of vertices in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.Δout-Tuple{Any}" href="#Graphs.Δout-Tuple{Any}"><code>Graphs.Δout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Δout(g)</code></pre><p>Return the maximum <a href="#Graphs.outdegree-Tuple{AbstractGraph, Integer}"><code>outdegree</code></a> of vertices in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.δ-Tuple{Any}" href="#Graphs.δ-Tuple{Any}"><code>Graphs.δ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">δ(g)</code></pre><p>Return the minimum <a href="#Graphs.degree"><code>degree</code></a> of vertices in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.δin-Tuple{Any}" href="#Graphs.δin-Tuple{Any}"><code>Graphs.δin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">δin(g)</code></pre><p>Return the minimum <a href="ref"><code>indegree</code></a> of vertices in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.δout-Tuple{Any}" href="#Graphs.δout-Tuple{Any}"><code>Graphs.δout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">δout(g)</code></pre><p>Return the minimum <a href="#Graphs.outdegree-Tuple{AbstractGraph, Integer}"><code>outdegree</code></a> of vertices in <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/core.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.blockdiag-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph" href="#SparseArrays.blockdiag-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractGraph"><code>SparseArrays.blockdiag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blockdiag(g, h)</code></pre><p>Return a graph with <span>$|V(g)| + |V(h)|$</span> vertices and <span>$|E(g)| + |E(h)|$</span> edges where the vertices and edges from graph <code>h</code> are appended to graph <code>g</code>.</p><p><strong>Implementation Notes</strong></p><p>Preserves the eltype of the input graph. Will error if the number of vertices in the generated graph exceeds the <code>eltype</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g1 = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; g2 = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; blockdiag(g1, g2)
{8, 9} directed simple Int64 graph

julia&gt; foreach(println, edges(blockdiag(g1, g2)))
Edge 1 =&gt; 2
Edge 2 =&gt; 3
Edge 3 =&gt; 1
Edge 3 =&gt; 4
Edge 4 =&gt; 5
Edge 5 =&gt; 4
Edge 6 =&gt; 7
Edge 7 =&gt; 8
Edge 8 =&gt; 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L100-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse-Tuple{AbstractGraph}" href="#SparseArrays.sparse-Tuple{AbstractGraph}"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sparse(g)</code></pre><p>Return the default adjacency matrix of <code>g</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/acb3d1689193f4010fe286942659907a0cefd7dd/src/operators.jl#L490-L494">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matching/">« Matching</a><a class="docs-footer-nextpage" href="../degeneracy/">Degeneracy »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 23 December 2021 12:55">Thursday 23 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
