<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path and Traversal · Graphs.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Graphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Graphs.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting Started</a></li><li><a class="tocitem" href="../graphtypes/">Choosing A Graph Type</a></li><li><a class="tocitem" href="../types/">Graphs Types</a></li><li><a class="tocitem" href="../basicproperties/">Accessing Properties</a></li><li><a class="tocitem" href="../generators/">Making and Modifying Graphs</a></li><li><a class="tocitem" href="../persistence/">Reading / Writing Graphs</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../core/">Core Functions</a></li><li><a class="tocitem" href="../plotting/">Plotting Graphs</a></li><li class="is-active"><a class="tocitem" href>Path and Traversal</a><ul class="internal"><li><a class="tocitem" href="#Graph-Traversal"><span>Graph Traversal</span></a></li><li><a class="tocitem" href="#Random-walks"><span>Random walks</span></a></li><li><a class="tocitem" href="#Connectivity-/-Bipartiteness"><span>Connectivity / Bipartiteness</span></a></li><li><a class="tocitem" href="#Cycle-Detection"><span>Cycle Detection</span></a></li><li><a class="tocitem" href="#Minimum-Spanning-Trees-(MST)-Algorithms"><span>Minimum Spanning Trees (MST) Algorithms</span></a></li><li><a class="tocitem" href="#Shortest-Path-Algorithms"><span>Shortest-Path Algorithms</span></a></li><li><a class="tocitem" href="#Path-discovery-/-enumeration"><span>Path discovery / enumeration</span></a></li></ul></li><li><a class="tocitem" href="../coloring/">Coloring</a></li><li><a class="tocitem" href="../distance/">Distance</a></li><li><a class="tocitem" href="../centrality/">Centrality Measures</a></li><li><a class="tocitem" href="../linalg/">Linear Algebra</a></li><li><a class="tocitem" href="../matching/">Matching</a></li><li><a class="tocitem" href="../community/">Community Structures</a></li><li><a class="tocitem" href="../degeneracy/">Degeneracy</a></li><li><a class="tocitem" href="../integration/">Integration with other packages</a></li><li><a class="tocitem" href="../experimental/">Experimental Functionality</a></li><li><a class="tocitem" href="../parallel/">Parallel Algorithms</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../developing/">Developer Notes</a></li><li><a class="tocitem" href="../license/">License Information</a></li><li><a class="tocitem" href="../citing/">Citing Graphs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Path and Traversal</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Path and Traversal</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphs/Graphs.jl/blob/master/docs/src/pathing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Path-and-Traversal"><a class="docs-heading-anchor" href="#Path-and-Traversal">Path and Traversal</a><a id="Path-and-Traversal-1"></a><a class="docs-heading-anchor-permalink" href="#Path-and-Traversal" title="Permalink"></a></h1><p><em>Graphs.jl</em> provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.</p><p>Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by <code>[src,dst]</code> vertices. That is, <code>distmx[2,4] = 2.5</code> assigns the distance <code>2.5</code> to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs <code>distmx[4,2]</code> has to be set.</p><p>Default edge distances may be passed in via the</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Graphs.DefaultDistance</code>. Check Documenter&#39;s build log for details.</p></div></div><p>structure.</p><p>Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,</p><ol><li>distance values for undefined edges will be ignored, and</li><li>any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.</li><li>any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.</li></ol><h2 id="Graph-Traversal"><a class="docs-heading-anchor" href="#Graph-Traversal">Graph Traversal</a><a id="Graph-Traversal-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Traversal" title="Permalink"></a></h2><p><em>Graph traversal</em> refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:</p><ul><li><code>BreadthFirst</code>,</li><li><code>DepthFirst</code>, and</li><li><code>MaximumAdjacency</code>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="Graphs.bfs_tree" href="#Graphs.bfs_tree"><code>Graphs.bfs_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bfs_tree(g, s[; dir=:out])</code></pre><p>Provide a breadth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>, and return a directed acyclic graph of vertices in the order they were discovered. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/bfs.jl#L68-L75">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>topological_sort_by_dfs</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.dfs_tree" href="#Graphs.dfs_tree"><code>Graphs.dfs_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dfs_tree(g, s)</code></pre><p>Return an ordered vector of vertices representing a directed acyclic graph based on depth-first traversal of the graph <code>g</code> starting with source vertex <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/dfs.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.maximum_adjacency_visit" href="#Graphs.maximum_adjacency_visit"><code>Graphs.maximum_adjacency_visit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximum_adjacency_visit(g[, distmx][, log][, io][, s])
maximum_adjacency_visit(g[, s])</code></pre><p>Return the vertices in <code>g</code> traversed by maximum adjacency search, optionally starting from vertex <code>s</code> (default <code>1</code>). An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1. If <code>log</code> (default <code>false</code>) is <code>true</code>, visitor events will be printed to <code>io</code>, which defaults to <code>STDOUT</code>; otherwise, no event information will be displayed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/maxadjvisit.jl#L73-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bfs_parents" href="#Graphs.bfs_parents"><code>Graphs.bfs_parents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bfs_parents(g, s[; dir=:out])</code></pre><p>Perform a breadth-first search of graph <code>g</code> starting from vertex <code>s</code>. Return a vector of parent vertices indexed by vertex. If <code>dir</code> is specified, use the corresponding edge direction (<code>:in</code> and <code>:out</code> are acceptable values).</p><p><strong>Performance</strong></p><p>This implementation is designed to perform well on large graphs. There are implementations which are marginally faster in practice for smaller graphs, but the performance improvements using this implementation on large graphs can be significant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/bfs.jl#L21-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_path" href="#Graphs.has_path"><code>Graphs.has_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_path(g::AbstractGraph, u, v; exclude_vertices=Vector())</code></pre><p>Return <code>true</code> if there is a path from <code>u</code> to <code>v</code> in <code>g</code> (while avoiding vertices in <code>exclude_vertices</code>) or <code>u == v</code>. Return false if there is no such path or if <code>u</code> or <code>v</code> is in <code>excluded_vertices</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/bfs.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.diffusion" href="#Graphs.diffusion"><code>Graphs.diffusion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diffusion(g, p, n)</code></pre><p>Run diffusion simulation on <code>g</code> for <code>n</code> steps with spread probabilities based on <code>p</code>. Return a vector with the set of new vertices reached at each step of the simulation.</p><p><strong>Optional Arguments</strong></p><ul><li><code>initial_infections=sample(vertices(g), 1)</code>: A list of vertices that</li></ul><p>are infected at the start of the simulation.</p><ul><li><code>watch=Vector()</code>: While simulation is always run on the full graph,</li></ul><p>specifying <code>watch</code> limits reporting to a specific set of vertices reached during the simulation. If left empty, all vertices will be watched.</p><ul><li><code>normalize=false</code>: if <code>false</code>, set the probability of spread from a vertex <span>$i$</span> to</li></ul><p>each of the outneighbors of <span>$i$</span> to <span>$p$</span>. If <code>true</code>, set the probability of spread from a vertex <span>$i$</span> to each of the <code>outneighbors</code> of <span>$i$</span> to <span>$\frac{p}{outdegreee(g, i)}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/diffusion.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.diffusion_rate" href="#Graphs.diffusion_rate"><code>Graphs.diffusion_rate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diffusion_rate(results)
diffusion_rate(g, p, n; ...)</code></pre><p>Given the results of a <code>diffusion</code> output or the parameters to the <code>diffusion</code> simulation itself, (run and) return the rate of diffusion as a vector representing the cumulative number of vertices infected at each simulation step, restricted to vertices included in <code>watch</code>, if specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/diffusion.jl#L77-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.mincut" href="#Graphs.mincut"><code>Graphs.mincut</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mincut(g, distmx=weights(g))</code></pre><p>Return a tuple <code>(parity, bestcut)</code>, where <code>parity</code> is a vector of integer values that determines the partition in <code>g</code> (1 or 2) and <code>bestcut</code> is the weight of the cut that makes this partition. An optional <code>distmx</code> matrix may be specified; if omitted, edge distances are assumed to be 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/maxadjvisit.jl#L11-L18">source</a></section></article><h2 id="Random-walks"><a class="docs-heading-anchor" href="#Random-walks">Random walks</a><a id="Random-walks-1"></a><a class="docs-heading-anchor-permalink" href="#Random-walks" title="Permalink"></a></h2><p><em>Graphs</em> includes uniform random walks and self avoiding walks:</p><article class="docstring"><header><a class="docstring-binding" id="Graphs.randomwalk" href="#Graphs.randomwalk"><code>Graphs.randomwalk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randomwalk(g, s, niter; seed=-1)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/randomwalks.jl#L1-L6">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>non_backtracking_randomwalk</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.self_avoiding_walk" href="#Graphs.self_avoiding_walk"><code>Graphs.self_avoiding_walk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">self_avoiding_walk(g, s, niter; seed=-1)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/randomwalks.jl#L95-L101">source</a></section></article><h2 id="Connectivity-/-Bipartiteness"><a class="docs-heading-anchor" href="#Connectivity-/-Bipartiteness">Connectivity / Bipartiteness</a><a id="Connectivity-/-Bipartiteness-1"></a><a class="docs-heading-anchor-permalink" href="#Connectivity-/-Bipartiteness" title="Permalink"></a></h2><p><code>Graph connectivity</code> functions are defined on both undirected and directed graphs:</p><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_connected" href="#Graphs.is_connected"><code>Graphs.is_connected</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_connected(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is connected. For directed graphs, return <code>true</code> if graph <code>g</code> is weakly connected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; is_connected(g)
true

julia&gt; g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; is_connected(g)
false

julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_connected(g)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/connectivity.jl#L105-L128">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_strongly_connected</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_weakly_connected" href="#Graphs.is_weakly_connected"><code>Graphs.is_weakly_connected</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_weakly_connected(g)</code></pre><p>Return <code>true</code> if the graph <code>g</code> is weakly connected. If <code>g</code> is undirected, this function is equivalent to <a href="../community/#Graphs.is_connected-Tuple{AbstractGraph}"><code>is_connected(g)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 0 0 1; 1 0 0]);

julia&gt; is_weakly_connected(g)
true

julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; is_connected(g)
true

julia&gt; is_strongly_connected(g)
false

julia&gt; is_weakly_connected(g)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/connectivity.jl#L152-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.connected_components" href="#Graphs.connected_components"><code>Graphs.connected_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">connected_components(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">connected components</a> of an undirected graph <code>g</code> as a vector of components, with each element a vector of vertices belonging to the component.</p><p>For directed graphs, see <a href="../community/#Graphs.strongly_connected_components"><code>strongly_connected_components</code></a> and <a href="#Graphs.weakly_connected_components"><code>weakly_connected_components</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleGraph([0 1 0; 1 0 1; 0 1 0]);

julia&gt; connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]

julia&gt; g = SimpleGraph([0 1 0 0 0; 1 0 1 0 0; 0 1 0 0 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; connected_components(g)
2-element Array{Array{Int64,1},1}:
 [1, 2, 3]
 [4, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/connectivity.jl#L72-L97">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>strongly_connected_components</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>strongly_connected_components_kosaraju</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.weakly_connected_components" href="#Graphs.weakly_connected_components"><code>Graphs.weakly_connected_components</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">weakly_connected_components(g)</code></pre><p>Return the weakly connected components of the graph <code>g</code>. This is equivalent to the connected components of the undirected equivalent of <code>g</code>. For undirected graphs this is equivalent to the <a href="#Graphs.connected_components"><code>connected_components</code></a> of <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0; 1 0 1; 0 0 0]);

julia&gt; weakly_connected_components(g)
1-element Array{Array{Int64,1},1}:
 [1, 2, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/connectivity.jl#L134-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.has_self_loops" href="#Graphs.has_self_loops"><code>Graphs.has_self_loops</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_self_loops(g)</code></pre><p>Return true if <code>g</code> has any self loops.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(2);

julia&gt; add_edge!(g, 1, 2);

julia&gt; has_self_loops(g)
false

julia&gt; add_edge!(g, 1, 1);

julia&gt; has_self_loops(g)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/core.jl#L326-L347">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>attracting_components</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.is_bipartite" href="#Graphs.is_bipartite"><code>Graphs.is_bipartite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_bipartite(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; is_bipartite(g)
true

julia&gt; add_edge!(g, 1, 3);

julia&gt; is_bipartite(g)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/bipartition.jl#L67-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bipartite_map" href="#Graphs.bipartite_map"><code>Graphs.bipartite_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bipartite_map(g) -&gt; Vector{UInt8}</code></pre><p>For a bipartite graph <code>g</code>, return a vector <code>c</code> of size <span>$|V|$</span> containing the assignment of each vertex to one of the two sets (<span>$c_i == 1$</span> or <span>$c_i == 2$</span>). If <code>g</code> is not bipartite, return an empty vector.</p><p><strong>Implementation Notes</strong></p><p>Note that an empty vector does not necessarily indicate non-bipartiteness. An empty graph will return an empty vector but is bipartite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; g = SimpleGraph(3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x01
 0x01

julia&gt; add_vertices!(g, 3);

julia&gt; add_edge!(g, 1, 2);

julia&gt; add_edge!(g, 2, 3);

julia&gt; bipartite_map(g)
3-element Array{UInt8,1}:
 0x01
 0x02
 0x01</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/bipartition.jl#L1-L36">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>biconnected_components</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>condensation</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighborhood" href="#Graphs.neighborhood"><code>Graphs.neighborhood</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighborhood(g, v, d, distmx=weights(g))</code></pre><p>Return a vector of each vertex in <code>g</code> at a geodesic distance less than or equal to <code>d</code>, where distances may be specified by <code>distmx</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood(g, 1, 2)
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; neighborhood(g, 1, 3)
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; neighborhood(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Int64,1}:
 1
 2
 3
 4
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/connectivity.jl#L597-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.neighborhood_dists" href="#Graphs.neighborhood_dists"><code>Graphs.neighborhood_dists</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">neighborhood_dists(g, v, d, distmx=weights(g))</code></pre><p>Return a a vector of tuples representing each vertex which is at a geodesic distance less than or equal to <code>d</code>, along with its distance from <code>v</code>. Non-negative distances may be specified by <code>distmx</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = SimpleDiGraph([0 1 0 0 0; 0 0 1 0 0; 1 0 0 1 0; 0 0 0 0 1; 0 0 0 1 0]);

julia&gt; neighborhood_dists(g, 1, 3)
4-element Array{Tuple{Int64,Int64},1}:
 (1, 0)
 (2, 1)
 (3, 2)
 (4, 3)

julia&gt; neighborhood_dists(g, 1, 3, [0 1 0 0 0; 0 0 1 0 0; 1 0 0 0.25 0; 0 0 0 0 0.25; 0 0 0 0.25 0])
5-element Array{Tuple{Int64,Float64},1}:
 (1, 0.0)
 (2, 1.0)
 (3, 2.0)
 (4, 2.25)
 (5, 2.5)

julia&gt; neighborhood_dists(g, 4, 3)
2-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (5, 1)

julia&gt; neighborhood_dists(g, 4, 3, dir=:in)
5-element Array{Tuple{Int64,Int64},1}:
 (4, 0)
 (3, 1)
 (5, 1)
 (2, 2)
 (1, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/connectivity.jl#L636-L678">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>articulation</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>bridges</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>period</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.isgraphical" href="#Graphs.isgraphical"><code>Graphs.isgraphical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isgraphical(degs)</code></pre><p>Return true if the degree sequence <code>degs</code> is graphical. A sequence of integers is called graphical, if there exists a graph where the degrees of its vertices form that same sequence.</p><p><strong>Performance</strong></p><p>Time complexity: <span>$\mathcal{O}(|degs|*\log(|degs|))$</span>.</p><p><strong>Implementation Notes</strong></p><p>According to Erdös-Gallai theorem, a degree sequence <span>$\{d_1, ...,d_n\}$</span> (sorted in descending order) is graphic iff the sum of vertex degrees is even and the sequence obeys the property -</p><p class="math-container">\[\sum_{i=1}^{r} d_i \leq r(r-1) + \sum_{i=r+1}^n min(r,d_i)\]</p><p>for each integer r &lt;= n-1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/connectivity.jl#L702-L717">source</a></section></article><h2 id="Cycle-Detection"><a class="docs-heading-anchor" href="#Cycle-Detection">Cycle Detection</a><a id="Cycle-Detection-1"></a><a class="docs-heading-anchor-permalink" href="#Cycle-Detection" title="Permalink"></a></h2><p>In graph theory, a cycle is defined to be a path that starts from some vertex <code>v</code> and ends up at <code>v</code>.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>is_cyclic</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.cycle_basis" href="#Graphs.cycle_basis"><code>Graphs.cycle_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cycle_basis(g, root=nothing)</code></pre><p>Return a list of cycles which form a basis for cycles of the undirected graph <code>g</code>, optionally starting at node <code>root</code>.</p><p>A basis for cycles of a network is a minimal collection of cycles such that any cycle in the network can be written as a sum of cycles in the basis.  Here summation of cycles is defined as &quot;exclusive or&quot; of the edges. Cycle bases are useful, e.g. when deriving equations for electric circuits using Kirchhoff&#39;s Laws.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; elist = [(1,2),(2,3),(2,4),(3,4),(4,1),(1,5)];

julia&gt; g = SimpleGraph(SimpleEdge.(elist));

julia&gt; cycle_basis(g)
2-element Array{Array{Int64,1},1}:
 [2, 3, 4]
 [2, 1, 3]</code></pre><p><strong>References</strong></p><ul><li>Paton, K. An algorithm for finding a fundamental set of cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518. [https://dl.acm.org/citation.cfm?id=363232]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/cycles/basis.jl#L3-L29">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>maxsimplecycles</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplecycles</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplecycles_iter</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplecycles_hawick_james</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplecyclescount</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>simplecycleslength</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Graphs.simplecycles_limited_length" href="#Graphs.simplecycles_limited_length"><code>Graphs.simplecycles_limited_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simplecycles_limited_length(g, n, ceiling=10^6)</code></pre><p>Compute and return at most <code>ceiling</code> cycles of length at most <code>n</code> of the given graph. Both directed and undirected graphs are supported.</p><p><strong>Performance</strong></p><p>The number of cycles grows very fast with the number of vertices and the allowed length of the cycles. This function is intended for finding short cycles. If you want to find cycles of any length in a directed graph, <a href="../community/#Graphs.simplecycles"><code>simplecycles</code></a> or <a href="../community/#Graphs.simplecycles_iter"><code>simplecycles_iter</code></a> may be more efficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/cycles/limited_length.jl#L1-L13">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>karp_minimum_cycle_mean</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Minimum-Spanning-Trees-(MST)-Algorithms"><a class="docs-heading-anchor" href="#Minimum-Spanning-Trees-(MST)-Algorithms">Minimum Spanning Trees (MST) Algorithms</a><a id="Minimum-Spanning-Trees-(MST)-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Minimum-Spanning-Trees-(MST)-Algorithms" title="Permalink"></a></h2><p>A Minimum Spanning Tree (MST) is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>kruskal_mst</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>prim_mst</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Shortest-Path-Algorithms"><a class="docs-heading-anchor" href="#Shortest-Path-Algorithms">Shortest-Path Algorithms</a><a id="Shortest-Path-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Shortest-Path-Algorithms" title="Permalink"></a></h2><h3 id="General-properties-of-shortest-path-algorithms"><a class="docs-heading-anchor" href="#General-properties-of-shortest-path-algorithms">General properties of shortest path algorithms</a><a id="General-properties-of-shortest-path-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#General-properties-of-shortest-path-algorithms" title="Permalink"></a></h3><ul><li>The distance from a vertex to itself is always <code>0</code>.</li><li>The distance between two vertices with no connecting edge is always <code>Inf</code>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="Graphs.a_star" href="#Graphs.a_star"><code>Graphs.a_star</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">a_star(g, s, t[, distmx][, heuristic])</code></pre><p>Return a vector of edges comprising the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to <a href="../community/#Graphs.DefaultDistance"><code>Graphs.DefaultDistance</code></a> and the heuristic is set to <code>n -&gt; 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/astar.jl#L58-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.dijkstra_shortest_paths" href="#Graphs.dijkstra_shortest_paths"><code>Graphs.dijkstra_shortest_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dijkstra_shortest_paths(g, srcs, distmx=weights(g));</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> on a graph, computing shortest distances between <code>srcs</code> and all other vertices. Return a <a href="../community/#Graphs.DijkstraState"><code>Graphs.DijkstraState</code></a> that contains various traversal information.</p><p><strong>Optional Arguments</strong></p><ul><li><code>allpaths=false</code>: If true, returns a <a href="../community/#Graphs.DijkstraState"><code>Graphs.DijkstraState</code></a> that keeps track of all</li></ul><p>predecessors of a given vertex.</p><p><strong>Performance</strong></p><p>If using a sparse matrix for <code>distmx</code>, you <em>may</em> achieve better performance by passing in a transpose of its sparse transpose. That is, assuming <code>D</code> is the sparse distance matrix:</p><pre><code class="language-none">D = transpose(sparse(transpose(D)))</code></pre><p>Be aware that realizing the sparse transpose of <code>D</code> incurs a heavy one-time penalty, so this strategy should only be used when multiple calls to <code>dijkstra_shortest_paths</code> with the distance matrix are planned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; ds = dijkstra_shortest_paths(cycle_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 2

julia&gt; ds = dijkstra_shortest_paths(path_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/dijkstra.jl#L14-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.desopo_pape_shortest_paths" href="#Graphs.desopo_pape_shortest_paths"><code>Graphs.desopo_pape_shortest_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">desopo_pape_shortest_paths(g, src, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>src</code> and all other nodes in graph <code>g</code> using the <a href="http://web.mit.edu/dimitrib/www/SLF.pdf">D&#39;Esopo-Pape algorithm</a>. Return a <a href="../community/#Graphs.DEsopoPapeState"><code>Graphs.DEsopoPapeState</code></a> with relevant traversal information.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Graphs

julia&gt; ds = desopo_pape_shortest_paths(cycle_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 2

julia&gt; ds = desopo_pape_shortest_paths(path_graph(5), 2);

julia&gt; ds.dists
5-element Array{Int64,1}:
 1
 0
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/desopo-pape.jl#L11-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.bellman_ford_shortest_paths" href="#Graphs.bellman_ford_shortest_paths"><code>Graphs.bellman_ford_shortest_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, ss, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> (or list of sources <code>ss</code>) and all other nodes in graph <code>g</code> using the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. Return a <a href="../community/#Graphs.BellmanFordState"><code>Graphs.BellmanFordState</code></a> with relevant traversal information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/bellman-ford.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.floyd_warshall_shortest_paths" href="#Graphs.floyd_warshall_shortest_paths"><code>Graphs.floyd_warshall_shortest_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">floyd_warshall_shortest_paths(g, distmx=weights(g))</code></pre><p>Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>. Return a <a href="../community/#Graphs.FloydWarshallState"><code>Graphs.FloydWarshallState</code></a> with relevant traversal information.</p><p><strong>Performance</strong></p><p>Space complexity is on the order of <span>$\mathcal{O}(|V|^2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/floyd-warshall.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.yen_k_shortest_paths" href="#Graphs.yen_k_shortest_paths"><code>Graphs.yen_k_shortest_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Yen%27s_algorithm">Yen&#39;s algorithm</a> on a graph, computing k-shortest distances between <code>source</code> and <code>target</code> other vertices. Return a <a href="../community/#Graphs.YenState"><code>YenState</code></a> that contains distances and paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/yen.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.spfa_shortest_paths" href="#Graphs.spfa_shortest_paths"><code>Graphs.spfa_shortest_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spfa_shortest_paths(g, s, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> and all other nodes in graph <code>g</code> using the <a href="https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm">Shortest Path Faster Algorithm</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g = complete_graph(3);

julia&gt; d = [1 -3 1; -3 1 1; 1 1 1];

julia&gt; spfa_shortest_paths(g, 1, d)

ERROR: Graphs.NegativeCycleError()

julia&gt; g = complete_graph(4);

julia&gt; d = [1 1 -1 1; 1 1 -1 1; 1 1 1 1; 1 1 1 1];

julia&gt; spfa_shortest_paths(gx, 1, d)

4-element Array{Int64,1}:
  0
  0
 -1
  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/spfa.jl#L12-L43">source</a></section></article><h2 id="Path-discovery-/-enumeration"><a class="docs-heading-anchor" href="#Path-discovery-/-enumeration">Path discovery / enumeration</a><a id="Path-discovery-/-enumeration-1"></a><a class="docs-heading-anchor-permalink" href="#Path-discovery-/-enumeration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Graphs.gdistances" href="#Graphs.gdistances"><code>Graphs.gdistances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gdistances(g, source; sort_alg=QuickSort)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/bfs.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.gdistances!" href="#Graphs.gdistances!"><code>Graphs.gdistances!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gdistances!(g, source, dists; sort_alg=QuickSort)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from source vertex (or collection of vertices) <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>  filled with <code>typemax(T)</code>. Return <code>dists</code>.</p><p>For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/traversals/bfs.jl#L78-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Graphs.enumerate_paths" href="#Graphs.enumerate_paths"><code>Graphs.enumerate_paths</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">enumerate_paths(state[, vs])</code></pre><p>Given a path state <code>state</code> of type <code>AbstractPathState</code>, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p><strong>Implementation Notes</strong></p><p>For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: <code>enumerate_paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>enumerate_paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>enumerate_paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphs/Graphs.jl/blob/3e4d7ef8a8489ca4903790abaab1df2e0ef4be03/src/shortestpaths/bellman-ford.jl#L92-L112">source</a></section></article><h3 id="Path-States"><a class="docs-heading-anchor" href="#Path-States">Path States</a><a id="Path-States-1"></a><a class="docs-heading-anchor-permalink" href="#Path-States" title="Permalink"></a></h3><p>All path states derive from</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Graphs.AbstractPathState</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The <code>dijkstra_shortest_paths</code>, <code>floyd_warshall_shortest_paths</code>, <code>bellman_ford_shortest_paths</code>, and <code>yen_shortest_paths</code> functions return states that contain various  information about the graph learned during traversal.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Graphs.DijkstraState</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Graphs.DEsopoPapeState</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Graphs.BellmanFordState</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Graphs.FloydWarshallState</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Graphs.YenState</code>. Check Documenter&#39;s build log for details.</p></div></div><p>The above state types (with the exception of <code>YenState</code>) have the following common information, accessible via the type:</p><p><code>.dists</code> Holds a vector of distances computed, indexed by source vertex.</p><p><code>.parents</code> Holds a vector of parents of each vertex on the paths. The parent of a source vertex is always <code>0</code>.</p><p>(<code>YenState</code> substitutes <code>.paths</code> for <code>.parents</code>.)</p><p>In addition, the following information may be populated with the appropriate arguments to <code>dijkstra_shortest_paths</code>:</p><p><code>.predecessors</code> Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.</p><p><code>.pathcounts</code> Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the <code>.predecessors</code> output above.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../plotting/">« Plotting Graphs</a><a class="docs-footer-nextpage" href="../coloring/">Coloring »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 17 January 2022 17:31">Monday 17 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
